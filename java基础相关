java基础相关

1、面向过程与面向对象
	面向过程：
		优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源；
		缺点：没有面向对象易维护、易复用、易扩展
	面向对象：
		优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统
		缺点：性能比面向过程低
2、继承和多态
	继承：保持已有类的特性而构造新类的过程。继承后，子类能够利用父类中定义的变量和方法，就像它们属于子类本身一样
	单继承：java类是单继承的，一个类只允许有一个父类
	多继承：java接口是多继承的，一个类允许继承多个接口
	多态：在父类中定义的属性和方法被子类继承之后，可以具有不同的数据结构或表现出不同的行为，这使得同一个属性或方法在父类及其各个子类中具有不同的含义
	子类对象的多态性使用前提：
		有类的继承
		由子类对父类方法的重写
	封装：隐藏内部代码
	继承：复用现有代码
	多态：改写对象行为
3、抽象类和接口
	抽象类：java中，用abstract关键字来修饰一个类时，这个类叫做抽象类。抽象类是它的所有子类的公共属性的集合，是包含一个或多个抽象方法的类，抽象类可以看做是对类的进一步抽象。在面向对象领域，抽象类主要用来进行类型隐藏
		两个注意点：
			如果一个类中有一个抽象方法，那么当前类一定是抽象类；但抽象类中不一定有抽象方法
			抽象类中的抽象方法，需要有子类实现，如果子类不实现，则子类也需要定义为抽象的
	接口：是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）
		两个注意点：
			接口中的所有属性默认为：public static final xxx
			接口中的所有方法默认为：public abstract xxx
	抽象类和接口的区别：
		抽象类可以有构造方法，接口没有构造方法
		抽象类可以有普通成员变量，接口没有普通成员变量
		抽象类可以有非抽象的普通方法，接口中的方法必须是抽象的
		抽象类可以包含静态方法，接口中不能包含静态方法
		一个类可以实现多个接口，但只能继承一个抽象类
		抽象类中的抽象方法访问类型可以是public protected，接口中的抽象方法必须是public
		接口中的基本数据类型的数据成员，都默认为static final ，抽象类则不是
	普通类和抽象类有哪些区别？
		普通类不能包含抽象方法，抽象类可以包含抽象方法
		抽象类不能直接实例化，普通类可以直接实例化
	抽象类能使用final修饰吗
		不能，定义抽象类就是让其他类继承的，如果定义为final该类就不能被继承，这样彼此就会产生矛盾，所以final不能修饰抽象类

4、JRE JDK JVM
	JRE：java runtime environment java运行环境，就是java平台。包含基本类库+java虚拟机。所有的java程序都要在JRE下才能运行。普通用户只需要运行已开发好的java程序，安装JRE即可

	JDK：java development kit java开发工具包+JRE，是程序开发者用来编译、调试java程序用的开发工具包。JDK的为java开发工具包+JRE。

	JVM:JVM是JRE的一部分。它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台。java程序运行在虚拟机上，不同的平台有不同的虚拟机

	JVM将内存区域划分为：方法区、堆、本地方法栈、程序计数器、虚拟机栈。其中方法区和堆是线程共享的，而另外三个是非线程共享的
	JVM初始运行时都会分配好方法区和堆，而JVM每遇到一个线程，就会为其分配一个程序计数器、虚拟机栈、本地方法栈。当线程终止时，三者所占的内存空间就会被释放掉。也就是说，线程私有的那三个区域的生命周期与所属线程相同，而线程共享的区域与JAVA程序运行的生命周期相同，所以这也是系统垃圾回收的场所只发生在线程共享的区域（实际上对大部分虚拟机来说只发生在堆上）的原因

	方法区：方法区是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息、常量、静态变量、即编译器编译后的代码等数据。
	堆：是java虚拟机所管理的内存中最大的一块，它是所有线程共享的一块内存区域。几乎所有的对象实例和数组都在这里分配内存。堆是垃圾收集器管理的主要区域，因此很多时候也被称为GC堆
	程序计数器：是一块较小的内存空间，它的作用可以看做当前线程所执行的字节码的行号指示器。为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器
	虚拟机栈：系统自动分配与回收内存，效率较高，快速，存取速度比堆快；java会自动释放掉为该变量所分配的内存空间，主要存储局部变量、操作数栈、动态链接、方法返回地址
	本地方法栈：本地方法栈与虚拟机栈作用类似，其区别不过是虚拟机栈为虚拟机执行java方法服务，而本地方法栈则是为虚拟机使用到的native方法服务
	jvm的参数：
		verbose:gc 表示启动jvm的时候，输出jvm里面的gc信息
		-XX:printGC 打印gc信息
		-XX+PrintGCDetails:打印GC的详细信息
		-XX+PrintGCTimeStamps:打印GC发生的时间戳
		-X:loggc:log/gc.log:指定输出gc.log的文件位置
		-XX+TraceClassLoading:监控类的加载
		-XX:+PrintClassHistogram：跟踪参数
		-Xmx -Xms：表示设置堆内存的最大值和最小值
		-Xmn：设置新生代的内存大小。
		-XX:NewRatio：新生代和老年代的比例
		-Xss：设置栈的大小。栈都是每个线程独有一个，所有一般都是几百k的大小。

	成员变量---堆中
	局部变量---栈中
	静态变量---方法区中
	什么是跨平台性？原理是什么？
		所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上运行
		实现原理：java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序
	什么是字节码？采用字节码的最大好处是什么？
		字节码：java源代码经过虚拟机编译器编译后产生的文件（即扩展的.class文件），它不面向任何特定的处理器，只面向虚拟机
		采用字节码的好处：java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，java程序无须重新编译便可在多种不同的计算机上运行
	java类加载机制：
		虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。
		把实现类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作的代码模块称为“类加载器”。将class文件二进制数据放入方法区内，然后在堆内（heap）创建一个 java.lang.Class 对象，Class 对象封装了类在方法区内的数据结构，并且向开发者提供了访问方法区内的数据结构的接口。
		在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的
7、java内存区域
	方法区：主要存放的是我们自己写的各种类的相关信息
	程序计数器：执行字节码指令的地方
	栈：每个线程都独有的，存放局部变量的地方
	堆：实例化所有对象都存在堆里面
5、堆和栈的区别
	栈：它有编译器自动管理，无需我们手工控制；
    堆：申请和释放由程序员控制，并指明大小；
    栈内存储的是局部变量而堆内存储的是实体；
    栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短
    栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收
6、垃圾回收机制GC
	java虚拟机的一大特性，是用来释放内存中的资源，可以有效地防止内存泄露，有效的使用空闲的内存;GC主要集中在堆和方法区中，在程序运行期间，这部分内存的分配和使用都是动态的
	GC是在JVM中
	对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。
    判断一个对象是否存活，标记垃圾的算法主要有两种：
        引用计数法：给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1，当引用失效，就减1，计数器为0的对象就是不可能再被使用的，可以当作垃圾收集
        可达性分析算法：通过一系列GC root的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到GC root没有任何引用链相连的话，则证明此对象是不可用的
    垃圾回收算法：标记清除算法、复制算法、标记整理算法以及分代回收算法

7、多线程的实现方式
	1、继承thread类：本质上是实现了runnable接口的一个实例，代表一个线程的实例。让自己的类直接 extends thread,并在此类中复写run()方法。启动线程的方法就是通过thread类的start（）实例方法，start()方法将启动一个新线程，并执行其中的run()方法
		package com.clzhang.sample.thread;

		// 通过继承Thread类来创建线程类
		public class ThreadByExtends extends Thread {
		    private int i;

		    @Override
		    public void run() {
		        // 当线程类继承Thread类时，直接使用this即可获取当前线程句柄。
		        // 因此可以直接调用getName()方法返回当前线程的名称。
		        System.out.println("当前线程名称是：" + getName());

		        for (; i < 5; i++) {
		            System.out.println(getName() + ":" + i);
		            try {
		                // 保证让别的线程也有执行的机会
		                Thread.sleep(10);
		            } catch (InterruptedException e) {
		            }
		        }
		    }

		    public static void main(String[] args) {
		        // 静态方法没有this，只能通过Thread.currentThread获取当前线程句柄
		        System.out.println(Thread.currentThread().getName());
		        
		        // 创建、并启动第一条线程
		        new ThreadByExtends().start();
		        // 创建、并启动第二条线程
		        new ThreadByExtends().start();
		    }
		}

	2、实现runnable接口：如果自己的类已经继承另一个类了，就无法再直接extends Thread，此时，可以通过让它来实现Runnable接口来创建多线程
		package com.clzhang.sample.thread;

		/**
		 * 通过实现Runnable接口来创建线程类
		 * 1.Runnable非常适合多个相同线程来处理同一份资源的情况
		 * 2.Runnable可以避免由于Java的单继承机制带来的局限
		 * 3.如果想获取当前线程句柄，只能用Thread.currentThread()方法
		 */
		public class ThreadByRunnable implements Runnable {
		    private int i;

		    @Override
		    public void run() {
		        System.out.println("当前线程名称是：" + Thread.currentThread().getName());

		        for (; i < 5; i++) {
		            System.out.println(Thread.currentThread().getName() + ":" + i);

		            try {
		                // 因为sleep是静态方法，所以不需要通过Thread.currentThread()方法获取当前线程句柄
		                Thread.sleep(10);
		            } catch (InterruptedException e) {

		            }
		        }
		    }

		    public static void main(String[] args) {
		        ThreadByRunnable st = new ThreadByRunnable();
		        new Thread(st, "新线程1").start();
		        new Thread(st, "新线程2").start();
		    }
		}
	3、实现callable接口，重写call方法
	package com.clzhang.sample.thread;
	import java.util.concurrent.Callable;
	import java.util.concurrent.FutureTask;

	// 实现Callable接口来实现线程
	public class ThreadByCallable implements Callable<Integer> {
	    
	    @Override
	    public Integer call() {
	        System.out.println("当前线程名称是：" + Thread.currentThread().getName());

	        int i = 0;
	        for (; i < 5; i++) {
	            System.out.println("循环变量i的值：" + i);
	        }
	        
	        // call()方法有返回值
	        return i;
	    }

	    public static void main(String[] args) {
	        ThreadByCallable rt = new ThreadByCallable();

	        // 使用FutureTask来包装Callable对象
	        FutureTask<Integer> task = new FutureTask<Integer>(rt);
	        new Thread(task, "有返回值的线程").start();
	        try {
	            // 获取线程返回值
	            System.out.println("子线程的返回值：" + task.get());
	        } catch (Exception ex) {
	            ex.printStackTrace();
	        }
	    }
	}
8、多线程中的run方法和start方法
	run()方法：是在主线程中执行方法，和调用普通方法一样（按顺序执行，同步执行）
	start()方法：是创建了新的线程，在新的线程中执行（异步执行），只有通过调用线程类的start()方法可能真正达到多线程的目的。单独调用run()方法，是同步执行；通过start()调用run(),是异步执行。
9、同步和异步
	同步：发送一个请求，等待返回，然后再发送下一个请求。实现：1、synchronized 修饰 2、wait()和notify()。同步可以避免出现死锁，读脏数据的发生，一般共享某一资源的时候用，如果每个人都有修改权限，同时修改一个文件，有可能使一个人读取另一个人已经删除的内容，就会出错，同步就会按顺序来修改
	异步：发送一个请求，不等待返回，随时可以再发送下一个请求。

	同步和异步的最大区别：一个需要等待，另一个不需要等待。比如广播，就是一个异步例子。发起者不关心接收者的状态，不需要等待接收者的返回信息；电话，就是一个同步，发起者需要等待接收者接通电话后，通信才开始，需要等待接收者的返回信息
10、内存泄露和内存溢出
	内存泄露：是指分配出去的内存没有被回收回来，由于失去了对该内存区域的控制，因而造成了资源的浪费。JAVA中一般不会产生内存泄露，因为有垃圾回收器自动回收垃圾，但这也不绝对，当我们new了一个对象，并保存了其引用，但是后面一直没用它，而垃圾回收器又不会去回收它，这便造成内存泄露
	内存溢出：是指程序所需要的内存超出了系统所能分配的内存的上限
11、重写和重载
	重写：在方法前加上@override注解。其实就是在子类中把父类本身有的方法重新写一遍。
	重载：同名的方法有不同的参数列表（参数类型不同、参数个数不同、参数顺序不同）
	重载和重写都是实现多态的方式，但区别在于：
		重载实现的是编译时的多态性；而重写实现的是运行时的多态性
		重载发生在一个类中；重写发生在子类与父类之间
11、成员变量与局部变量的区别有哪些
	变量：在程序执行的过程中，在某个范围内其值可以发生改变的量，从本质上讲，变量其实是内存中的一小块区域
	成员变量：类内方法外
	局部变量：方法内
	成员变量与局部变量的区别有哪些？
				      成员变量                                              局部变量
		作用域：      针对整个类有效                                      只在某个范围内有效（一般指的就是方法，语句体内）
		存储位置       存储在堆中                                            存储在栈中
		生命周期      随着对象的创建而存在，随着对象的消失而消失              当方法调用完，或者语句结束后，就自动释放
		初始值        有默认初始值                                        没有默认初始值，使用前必须赋值
12、值传递和引用传递：
	值传递：指在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了
	引用传递：传递前传递后指向的是用一个引用
	java总是按值传递。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容
13、静态变量和实例变量的区别：
	语法区别：静态变量需要static关键字修饰，实例变量不需要
	从属区别：静态变量从属于类，实例变量从属于对象
	程序运行时的区别：
		静态变量即类变量，只要程序加载了类的字节码，静态变量就会被分配空间，即可使用
		实例变量必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量
	使用：
		静态变量可以直接使用类名来引用
		实例变量必须创建对象后通过这个对象来使用

12、static:静态，是一个修饰符，用于修饰成员（成员变量和成员函数）
	当成员被静态修饰后，就多了一种调用方式，除了可以被对象调用外，还可以直接被类名调用格式：类名.静态成员
	静态的特点：
			（1）随着类的加载而加载：也就是说，静态会随着类的消失而消失，说明静态的生命周期最长
			（2）优先于对象的存在：静态是先存在的，对象是后存在的
			（3）被所有对象共享
			（4）可以直接被类名.调用
	静态的使用注意事项：
		（1）静态方法只能访问静态成员（包含成员变量和成员方法）非静态方法可以访问静态也可以访问非静态
		（2）静态方法中不可以定义this，super关键字，因为静态优先于对象存在，所以静态方法中不可以出现this super关键字
		（3）主函数main是静态的
	静态的利弊：
		利：对对象的共享数据进行单独空间的存储，节省空间，没有必要每一个对象中都存储一份，可以直接被类名所调用
		弊：生命周期过长，访问出现局限性（只能访问静态）
13、final关键字
	（1）final修饰类：被final修饰的类不可以被继承。这样做的目的是可以保证该类不被修改，java的一些核心的API都是final类，例如string,integer,math等
	（2）final修饰方法：被final修饰的方法不能被重写
	（3）final修饰实例变量：final修饰实例变量时必须初始化，并且不可以被修改
	（4）final修饰局部变量：只能初始化（赋值）一次，但也可以不初始化
	（5）final修饰方法参数：是在调用方法传递参数时候初始化的
14、finalize关键字：
	finalize()是在java.lang.Object里定义的，也就是说每一个对象都有这么个方法。这个方法在gc启动，该对象被回收的时候被调用。其实gc可以回收大部分的对象（凡是new出来的对象，gc都能搞定，一般情况下我们又不会用new以外的方式去创建对象），所以一般是不需要程序员去实现finalize的。 
14、serializable关键字
	只要一个类实现了serilizable接口，这个类的所有属性和方法都会自动序列化
	序列化最主要的用处：在传递和保存对象的时候，保证对象的完整性和可传递性
	java中对象的序列化指的是将对象转换成以字节的形式表示，这些字节序列包含了对象的数据和信息，一个序列化后的对象可以被写到数据库或文件中，也可用于网络传输，一般当我们使用缓存cache或远程调用rpc（网络传输）的时候，经常需要让我们的实体类实现serializable接口，目的就是为了让其可序列化
	序列化的步骤：
		1、首先要创建某些OutputStream对象：OutputStream outputStream = new FileOutputStream("output.txt")
		2、将其封装到ObjectOutputStream对象内：ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream);
		3、此后只需调用writeObject()即可完成对象的序列化，并将其发送给OutputStream：objectOutputStream.writeObject(Object);
		4、最后不要忘记关闭资源：objectOutputStream.close(), outputStream .close();
	反序列化步骤：
		1、首先要创建某些OutputStream对象：InputStream inputStream= new FileInputStream("output.txt")
		2、将其封装到ObjectInputStream对象内：ObjectInputStream objectInputStream= new ObjectInputStream(inputStream);
		3、此后只需调用writeObject()即可完成对象的反序列化：objectInputStream.readObject();
		4、最后不要忘记关闭资源：objectInputStream.close()，inputStream.close();
15、transient关键字
	在实际开发过程中，我们常常会遇到这样的问题，这个类的有些属性需要序列化，而其他属性不需要被序列化，打个比方，如果一个用户有一些敏感信息，为了安全起见，不希望网络操作中被传输，这些信息对应的变量就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存而不会写到磁盘里持久化
	总结：在对象序列化实现serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定目的地中
16、volatile关键字：
	（1）、保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这个新值对其他线程来说是立即可见的---可见性
	（2）、禁止进行指令重排序----有序性
17、线程之间的同步：
	对于成员可以通过关键字private来保证被方法访问，因此无需特殊的设计
	对于方法，我们使用synchronized关键字--原子性，可见性
	使用volatail关键字--可见性，有序性
18、synchronized关键字和volatile关键字的区别
	1、含义：
		volatile主要用在多个线程感知实例变量被更改了场合，从而使得各个线程获得最新的值。它强制线程每次从主内存中读取数据，而不是从线程私有内存中读取数据，从而保证了数据的可见性
		synchronized主要通过对象锁控制线程对共享数据的访问，持有相同对象锁的线程只能等其他持有同一个对象锁的线程执行完毕之后，才能持有这个对象锁访问和处理共享数据
	2、量级比较：
		volatial轻量级，只能修饰变量
		synchronized重量级，还可修饰方法
	3、可见性和原子性
		volatail只能保证数据的可见性，不能用来同步，因为多个线程并发访问volatial修饰的变量不会阻塞
		synchronized不仅保证可见性，而且还保证原子性，因为，只有获得了锁的线程才能进入临界区，从而保证临界区中的所有语句都全部执行。多个线程争抢synchronized锁对象时，会出现阻塞

17、sleep和wait的区别
	sleep()是线程被调用时，占着cpu休眠，其他线程不能占用cpu，os认为该线程还在工作，不会让出系统资源，wait()是进入等待池等待，让出系统资源，其他线程可以占用cpu
15、& 和 &&
	& 按位与，and 运算符两边的表达式均为true时，整个结果才为true
	&& 逻辑与，如果第一个表达式为false，第二个表达式就不会计算了，有短路的作用
16、== 和equals
	==:
		基本数据类型比较的是值
		引用类型比较的是地址值
	equals：
		不能比较基本数据类型，比较引用类型时等同于==,也就是比较地址值，但是equals可以自己重新写规则
	应用场景：
		（1）如果是基本数据类型那么就用==比较
		（2）如果是引用类型的话，想按照自己的方式去比较，就要重写这个类中的equals方法，如果没有重写，那么equals和==比较的效果是一样的，都是比较引用的地址值
		（3）如果是比较字符串，那么直接用equals就可以了，因为string里面已经重写equals方法了，比较的是字符串的内容

18、error和exception
	error:系统级错误 表示系统级的错误和程序不必处理的异常，是java运行环境中的内部错误或者硬件问题。比如：内存资源不足等，对于这类错误，除了退出基本无能为力，它是由java虚拟机抛出的
	exception：可修复错误
		表示需要捕捉或需要程序进行处理的异常，是程序必须处理的 运行时异常：runtime exception：数组越界、空指针等等（编译通过，运行不通过）；一般异常：表示程序可以处理的异常，表示程序可以修复（程序自己接收异常并且对其进行catch）
19、 socket和http
	http已经很熟悉了，是应用层协议。而socket不属于协议范畴，而是一个调用接口，socket是对tcp/ip协议的封装，通过调用socket，才能使用tcp/ip协议。socket连接是长连接，理论上客户端和服务端一旦建立连接将不会主动断开此连接，它属于请求-响应形式，服务端可主动将消息推送给客户端
	是在应用层以下，传输层以上
20、集合
	collection 
		list: 有序（元素存入集合的顺序和取出的顺序一致），元素有索引。元素可以重复。 Arraylist（线程不安全，底层由数组实现） Linkedlist（线程不安全，底层是链表）
		set：无序（存入和取出顺序有可能不一致），不可以存储重复元素。必须保证元素的唯一性。Hashset Treeset

					 ArrayList                                LinkedList             Vector
	底层实现				数组                                      双向链表               数组
	同步性及效率		不同步、线程不安全、效率高、支持随机访问       不同步、线程不安全、效率高    同步、线程安全、效率低
	特点				查询快，增删慢                             查询慢，增删快               查询快，增删慢
	默认容量            10                                           /                       10
	list.get(i)

ArrayList的扩容机制：
		分为两步：
			1、扩容：把原来的数组复制到另一个内存空间更大的数组中
				在无参构造中，我们看到了在用无参构造来创建对象的时候其实就是创建了一个空数组，长度为0
				在有参构造中，传入的参数是正整数就按照传入的参数来确定创建数组的大小，否则异常

				(1)、当前数组是由默认构造方法生成的空数组并且第一次添加数据。此时minCapacity等于默认的容量（10）那么根据下面逻辑可以看到最后数组的容量会从0扩容成10。而后的数组扩容才是按照当前容量的1.5倍进行扩容；

				(2)、当前数组是由自定义初始容量构造方法创建并且指定初始容量为0。此时minCapacity等于1那么根据下面逻辑可以看到最后数组的容量会从0变成1。这边可以看到一个严重的问题，一旦我们执行了初始容量为0，那么根据下面的算法前四次扩容每次都 +1，在第5次添加数据进行扩容的时候才是按照当前容量的1.5倍进行扩容。

				（3）当扩容量（newCapacity）大于ArrayList数组定义的最大值后会调用hugeCapacity来进行判断。如果minCapacity已经大于Integer的最大值（溢出为负数）那么抛出OutOfMemoryError（内存溢出）否则的话根据与MAX_ARRAY_SIZE的比较情况确定是返回Integer最大值还是MAX_ARRAY_SIZE。这边也可以看到ArrayList允许的最大容量就是Integer的最大值（-2的31次方~2的31次方减1）。

			2、添加元素：把新元素添加到扩容之后的数组中

 
						HashSet                                 TreeSet                                LinkedHashSet
	底层实现             哈希算法                                   红黑树                                    链表
	重复性               不允许重复                               不允许重复                                不允许重复
	有无序				无序                    				     有序                                      有序
	时间复杂度    add() remove() contains()时间复杂度为O(1)      add() remove() contains()时间复杂度为O(LONG)  访问元素时效率比hashset好插入不如hashset
	同步性           不同步，线程不安全                           不同步，线程不安全                          不同步，线程不安全
	null值            允许null值                                不支持null值                                允许null值
	比较               equals()                                compareTo()                                 equals()

hashset如何检查重复：
		当你把对象加入hashset时，hashset会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，hashset会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals()方法来检查hashcode相等的对象是否真的相同。如果两者相同，hashset就不会让加入操作成功

hashcode 与equals的相关规定：
		如果两个对象相等，则hashcode一定也是相同
		两个对象相等，equals方法返回true
		两个对象有相同的hashcode值，它们也不一定相等的
什么是哈希表？

   	哈希表（Hash table，也叫散列表），是根据关键码值(Key value)直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。
	记录的存储位置=f(关键字)

	这里的对应关系f称为散列函数，又称为哈希（Hash函数），采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表（Hash table）。
	哈希表hashtable(key，value) 就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。（或者：把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。）
    而当使用哈希表进行查询的时候，就是再次使用哈希函数将key转换为对应的数组下标，并定位到该空间获取value，如此一来，就可以充分利用到数组的定位性能进行数据定位。

哈希表的实现原理：
    	哈希表的底层为一个长度较长的数组，通过将存放的各个元素进行一系列运算而转化为一串hash值，再通过相同的规则与数组的下标进行对应。但是，这并不能保证元素对应的下标唯一，可能存在两个元素运算后的hash值相同，从而指定到相同的下标（也会存在不同的hash值对应相同的数组下标），此时需要对这种冲突进行处理。
	哈希表的时间复杂度：O(1) -->没有哈希冲突的情况下；冲突的时候就要取决于平均查找长度O(c)

什么是哈希冲突，怎么处理哈希冲突 ，哈希碰撞 
	对象Hash的前提是实现equals()和hashCode()两个方法，那么HashCode()的作用就是保证对象返回唯一hash值，但当两个对象计算值一样时，这就发生了碰撞冲突。

    当关键字集合很大时，关键字值不同的元素可能会映像到哈希表的同一地址上，即k1 !=k2,f(k1) = f(k2),这种现象称为hash冲突，实际中哈希冲突是不可避免的，只能通过改进哈希函数的性能来减少冲突
    解决方式：
		再散列法： 基本思想：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。 这种方法有一个通用的再散列函数形式： 

		再哈希法：这种方法是同时构造多个不同的哈希函数： Hi=RH1（key）  i=1，2，…，k
		当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。

		拉链法（hashmap）： 基本思想: 将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。

list和arrayList的区别：
	   List是一个接口，而ArrayList是List接口的一个实现类。 
       ArrayList类是继承AbstractList抽象类和实现List接口的一个实现类。 
       因此，List接口不能被构造，也就是我们说的不能创建实例对象，但是我们可以像下面那样为List接口创建一个指向自己的对象引用，而ArrayList实现类的实例对象就在这充当了这个指向List接口的对象引用。 

	map （键值对集合）
		HashMap（哈希表、散列表）
		Treemap

	HashMap :存储键值对数据，用键来快速定位数据，来提取键对应的值。键：不重复，无序
			HashMap中的key-value都是存储在entry数组中
			HashMap的实现不是同步的，意味着它不是线程安全的
			HashMap的实例有两个参数影响其性能：初始容量和加载因子
			put(key,value)放入键值对数据，重复的键会覆盖旧值
			get(key)获得键对应的值，键不存在，得到null
			remove(key)异常键值对数据，返回被移除的值
			size()键值对数量
				             HashMap                                    hashtable                               treeMap
	底层实现                   哈希表（数组+链表）                          哈希表（数组+链表）                        红黑树
	同步性                    线程不同步                                   同步                                    线程不同步
	null值               key value可以为null值，但只允许一个key为null       不允许key value为null                  value可以为null
	默认容量						16（扩容的时候两倍扩容）						11（扩容的时候容量翻倍+1）
	
20、HashMap底层实现：
		总结：通过key的哈希值对数组长度取模存到对应的数组位置中，相同模的值通过链表串起来

		HashMap采用Entry数组来存储key-value对，每一个键值对组成了一个Entry实体，Entry类实际上是一个单向的链表结构，它具有Next指针，可以连接下一个Entry实体，以此来解决Hash冲突的问题。
		数据结构由数组+链表组成，一个长度为16的数组中，每个元素存储的是一个链表的头结点。那么这些元素是按照什么样的规则存储到数组中呢。一般情况是通过hash(key.hashCode())%len获得，也就是元素的key的哈希值对数组长度取模得到。比如上述哈希表中，12%16=12,28%16=12,108%16=12,140%16=12。所以12、28、108以及140都存储在数组下标为12的位置。

		HashMap里面实现一个静态内部类Entry，其重要的属性有 hash，key，value，next。

		HashMap里面用到链式数据结构的一个概念。上面我们提到过Entry类里面有一个next属性，作用是指向下一个Entry。打个比方， 第一个键值对A进来，通过计算其key的hash得到的index=0，记做:Entry[0] = A。一会后又进来一个键值对B，通过计算其index也等于0，现在怎么办？HashMap会这样做:B.next = A,Entry[0] = B,如果又进来C,index也等于0,那么C.next = B,Entry[0] = C；这样我们发现index=0的地方其实存取了A,B,C三个键值对,他们通过next这个属性链接在一起。所以疑问不用担心。也就是说数组中存储的是最后插入的元素。到这里为止，HashMap的大致实现，我们应该已经清楚了。
21、HashMap为什么线程不安全？
		hashmap的扩容：
			一般我们声明HashMap时，使用的都是默认的构造方法：HashMap<K,V>，看了代码你会发现，它还有其它的构造方法：HashMap(int initialCapacity, float loadFactor)，
			其中参数initialCapacity为初始容量，loadFactor为加载因子，扩容就是在put加入元素的个数超过initialCapacity * loadFactor的时候就会将内部Entry数组大小扩大至原来的2倍，然后将数组元素按照新的数组大小重新计算索引，放在新的数组中，同时修改每个节点的链表关系（主要是next和节点在链表中的位置）
		1.在JDK1.7中，当并发执行扩容操作时会造成环形链和数据丢失的情况。
		2.在JDK1.8中，在并发执行put操作时会发生数据覆盖的情况。

		总结版：HashMap在put的时候，插入的元素超过了容量（由负载因子决定）的范围就会触发扩容操作，就是rehash，这个会重新将原数组的内容重新hash到新的扩容数组中，在多线程的环境下，存在同时其他的元素也在进行put操作，如果hash值相同，可能出现同时在同一数组下用链表表示，造成闭环，entry的next节点永远不为空，导致在get时会出现死循环，所以HashMap是线程不安全的。
Hashmap,hashtable,concurrenthashmap:
	1）线程不安全的HashMap
	在多线程环境下，使用HashMap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。HashMap在并发执行put操作时会引起死循环，是因为多线程会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry。

	2）效率低下的HashTable
	HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法，其他线程也访问HashTable的同步方法时，会进入阻塞或轮询状态。如线程1使用put进行元素添加，线程2不但不能使用put方法添加元素，也不能使用get方法来获取元素，所以竞争越激烈效率越低。

	3）ConcurrentHashMap的锁分段技术可有效提升并发访问率
	HashTable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问HashTable的线程都必须竞争同一把锁，假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术。首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。

17、hashtable和hashmap的区别
	都实现了map接口,都是双列集合
	hashtable线程安全，hashmap线程不安全
	hashtable的key value不能为null,hashmap支持唯一null健，多个null值
18、String StringBuffer StringBuilder的区别：
	运行速度：StringBuilder > StringBuffer > String
	String为字符串常量，一旦创建之后该对象是不可更改的
	StringBuffer StringBuilder为字符串变量，可以改变
	String：适用于少量的字符串操作的情况
	StringBuilder:适用于单线程下在字符缓冲区进行大量操作的情况
	StringBuffer:适用于多线程下在字符串缓冲区进行大量操作的情况
19、数组指针和指针数组：
	int* a[4]     指针数组     
                 表示：数组a中的元素都为int型指针    
                 元素表示：*a[i]   *(a[i])是一样的，因为[]优先级高于*
	int (*a)[4]   数组指针     
                 表示：指向数组a的指针
                 元素表示：(*a)[i]  
21、java中的注解
	作用：
		（1）生成文档，这是最常见的 @param @return
		（2）跟踪代码依赖性，实现替代配置文件功能，作用就是减少配置，现在的框架基本都使用了这种配置来减少配置文件的数量
		（3）在编译时进行格式检查
	常见的注解（7个）
		（1）@override 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，就会编译报错
		（2）@deprecated 标记过时方法，如果使用该方法，会报编译警告
		（3）@suppresswarnings 提示编译器去忽略注解中声明的警告
		（4）@retention 标识这个注解怎么保存，是只写在代码中，还是编入class文件中，或者是在运行时可以通过反射访问
		（5）documented 标识这些注解是否包含在用户文档中
22、java中常用的包
	java.lang：这个是系统的基础类
	java.io：这里面是所有输入输出有关的类
	java.nio：为了完善io包中的功能，提高io包中性能而写的一个新包
	java,net:这里面是与网络有关的类
	java.util：系统辅助类，集合类
	java.sql：这个是数据库操作的类
23、什么是反射机制：
	java反射机制是在运行状态中，对于任意一个类，都能获得这个类的所有属性和方法；对于任意一个对象都能调用它的任意一个属性和方法。这种在运行时动态的获取信息以及动态调用对象的方法的功能称为java的反射机制

	反射是运行中的程序检查自己和软件运行环境的能力，通俗的讲，反射可以在运行时根据指定的类名获得类的信息

	JAVA获取反射的三种方法：
	（1）通过new对象实现反射机制
	（2）通过路径实现反射机制
	（3）通过类名实现反射机制

	反射的优缺点：
		优点：运行期类型的判断，动态类加载，动态代理使用反射
		缺点：性能是一个问题，反射相当于一系列解释操作，通知jvm要做的事情，性能比直接的java代码要慢很多
24、Math.round(11.5) = 12 ,Math.round(-11.5) = 11
	round 表示"四舍五入"，算法为Math.floor(x+0.5) ，即将原来的数字加上 0.5 后再向下取整，所以 Math.round(11.5) 的结果为 12，Math.round(-11.5) 的结果为 -11。
25、JAVA使用什么编码方式？有何特点
	java语言采用unicode编码标准，unicode编码，它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心使用
26、java的面向对象：
	封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性
	继承：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性的继承父类。通过使用继承可以提高代码的复用性。继承是多态的前提
		关于继承有3点要记住：
			子类拥有父类非private的属性和方法
			子类可以拥有自己的属性和方法，即子类可以对父类进行扩展
			子类可以用自己的方式实现父类的方法
	多态：父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的扩展性
		在java中有两种形式可以实现多态：接口、继承
		一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类实现的方法，必须是由程序运行期间才能决定。
		运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：
			方法重写（子类继承父类并重写父类中已有的或抽象的方法）
			对象造型（用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不通过而表现出不同的行为）
		什么是多态机制？
			所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。
			因为在程序运行时才确定具体的类，这样，不用修改源程序的代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性
27、内存泄漏与内存溢出：
	内存泄漏：是指程序在申请内存之后，无法释放已申请的内存空间，一次内存泄漏危害可以忽略，但多次后果很严重
    内存溢出：程序在申请内存时，没有足够的内存空间供其使用
	两者关系：内存泄漏最终会导致内存溢出
28、java中会内存泄漏吗？
	1、当生命周期长的对象持有短生命周期的引用，就很有可能发生内存泄漏。尽管短生命周期的对象已经不再需要，但是长生命周期的对象一直持有它的引用导致其无法被回收。例如缓存系统，加载一个对象放在缓存系统中，一直不去使用这个对象，但是它一直被缓存引用，所以不会被回收导致缓存泄漏
	2、当一个对象被存储进HashSet集合中，就不可修改这个对象中用于计算哈希值的属性了。否则，对象修改后的哈希值与刚添加进hashSet集合时的哈希值不一样，此时如果将当前的引用作为参数，用contains方法判断对象是否存在，则会返回找不到对象的结果，这会导致无法从HashSet单独删除当前对象，造成内存泄漏

27、java迭代器：不是一个集合，是一种访问集合的方法，可用于迭代ArrayList 和 HashSet等集合
	it.next() 会返回迭代器的下一个元素，并且更新迭代器的状态
	it.hashNext() 用于检测集合中是否还有元素
	it.remove()将迭代器返回的元素删除

	ArrayList<String> list = new ArrayList<>()
	Iterator<String> it = list.iterator();
	while(it.hasNext()){
		sysout(it.next)
	}

29、为什么要使用线程池：
	创建线程和销毁线程的花销是比较大的，这些时间有可能比处理业务的时间还要长。这样频繁的创建线程和销毁线程，再加上业务工作流程，消耗系统资源的时间，可能导致系统资源不足
30、线程池有什么作用？
	（1）提高效率。创建好一定数量的线程放在线程池里，等需要使用的时候就从池中拿一个，这比需要的时候创建一个线程对象要快得多
	（2）方便管理。可以编写线程管理代码对池中的线程统一管理，比如说启动时有该线程创建的100个线程，每当有请求的时候，就分配一个线程去工作，如果刚好有并发有101个请求，那多出来的这个请求可以进行排队等候，避免无休止的创建线程导致系统奔溃
31、线程池有哪些：
	newSingleThreadExecutor:创建一个单线程化的线程池，只会用一个线程来执行任务，保证所有任务按照指定顺序来执行
	newFixedThreadPool:创建一个定长线程池，可控制线程的最大并发数，超出的线程会在队列中等待
	newCachedThreadPool:创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程
32、线程池中有哪几种工作队列
	arrayBlockingQueue:基于数组结构的有界阻塞队列
	LinkedBlockingQueue：基于链表结构的阻塞队列
	synchronousQueue：不存储元素的阻塞队列
	priorityBlockingQueue:一个具有优先级的无限阻塞队列
33、线程中几种重要的参数：
	corePoolSize：核心池的大小
	maximumPoolSize：线程池最大线程数
	keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。
	unit：参数keepAliveTime的时间单位
	workQueue：一个阻塞队列
	threadFactory：用于设置创建线程的工厂

34、java的四种引用方式
    强引用： 是指创建一个对象并把这个对象赋给一个引用变量。 强引用有引用变量指向时永远不会被垃圾回收，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。
    软引用：如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它；
		如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。 软引用可用来实现内存敏感的高速缓存,比如网页缓存、图片缓存等
    弱引用: 弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示。
    虚引用： 虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。在java中用java.lang.ref.PhantomReference类表示。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。
35、内部类：
	就是在一个类内部进行其他类结构的嵌套操作
	优点：
		内部类与外部类可以方便的访问彼此的私有域（包括私有方法、私有属性）
		内部类是另外一种封装，对外部的其他类隐藏
		内部类可以实现java单继承的局限：使用内部类实现多继承
	缺点：
		结构复杂
36、c和java的区别
    1、java和c都是指令型语言，不同的是java是面向对象的，c是面向过程的
    2、java跨平台，即不同的操作系统都可以通过JVM来解释java程序，而c则是与平台相关的，有些指令只能在某些操作系统上才能执行。具体原因是，java是解释型语言，所以代码会翻译成统一的，与平台无关的字节码文件然后放到JVM上运行，而c是编译式语言，代码要先通过编译器转换成与系统相关的中间代码才能运行
    3、java不需要程序员来进行垃圾回收，而c则要用用free函数来释放空间
37、内存溢出
    栈溢出：栈是私有的，他的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量、操作栈、动态链接等，所以栈溢出就是方法执行时创建的栈帧超过了栈的深度，最有可能就是方法递归调用产生这种结果
    堆溢出：堆中主要存储的是对象，如果不断的new对象则会导致堆中的空间溢出
38、基本数据类型和所占字节
　　byte：1byte = 8bit　　　　 1个字节是8个bit
　　short：2byte
　　int：4byte
　　long：8byte
　　float：4byte
　　double：8byte
　　boolean：1byte
　　char：2byte
39、char 与varchar类型的区别：
	1、char的长度是不可变的，varchar的长度可变
    2、char的存取速度要比varchar快很多，因为其长度固定，方便程序的存储与查找
    3、char的存储方式是：英文字符占用1个字节，汉字占用2个字节；varchar的存储方式：英文字符占用2个字节，汉字也占用2个字节
    两者的应用场景：
        char:
            1、适合存储长度近似的值
            2、适合存储短字符串
            3、适合存储经常更新的字符串列
        varchar：
            1、字符串的最大长度比平均长度大很多
            2、字符串列很少被更新
40、java容器：
	容器可以管理对象的生命周期、对象与对象之间的依赖关系，您可以使用一个配置文件（通常是xml）,在上面定义好对象的名称、如何产生、哪个对象产生之后必须设定成为某个对象的属性等，在启动容器之后，所有的对象都可以直接取用，不用编写任何一行程序代码来产生对象，或是建立对象与对象之间的依赖关系
	java容器类包含List,set,map
39、线程安全
    1、在了解线程安全之前了解一下java的内存模型，先搞清楚线程是怎么工作的
    2、JVM是一种基于计算机内存模型，屏蔽了各种硬件和操作系统的访问差异，保证了java程序在各种平台下对内存访问都能保证效果一致的机制及规范。保证了共享内存的原子性、可见性、有序性
    3、每个线程都有自己的工作内存，线程需要读写主内存的共享变量时需要先将该变量拷贝一份到自己的工作内存，然后在自己的工作内存中对该变量进行所有操作，线程工作内存对变量副本完成操作之后需要将结果同步至主内存
    4、原子性：对共享内存的操作必须是要么全部执行直到执行结束，且中间过程不能被任何外部因素打断，要么就不执行
        可见性：多线程操作共享内存时，执行结果能够及时的同步到共享内存，确保其他线程对此结果及时可见
        有序性：程序的执行顺序按照代码顺序执行，在单线程环境下，程序的执行都是有序的，但是在多线程环境下，JVM为了性能优化，编译器和处理器会对指令进行重排，程序的执行会变成无序
    5、线程安全的本质：主内存中的变量是共享的，所有线程都可以访问读写，而线程工作内存又是线程私有的，线程间不可以互相访问，那在多线程场景下，线程A和线程B同时来操作共享内存中的同一个变量，那么主内存里的此变量数据就会被破坏，也就是说主内存内的此变量不是线程安全的
    6、那么java中如何保证线程安全、保证共享内存的原子性、可见性、有序性呢
	    第一种：synchronized关键字
	    线程同步：synchronized关键字-->作用保证方法或代码块操作的原子性：线程间互斥访问，即同一时间，由monitor（监视锁）监视的代码，最多只能有一个线程在访问
	    保证监视资源的可见性：保证多线程环境下对监视资源的数据同步。即任何线程在获取到monitor的第一时间，会先将共享内存中的数据复制到自己的缓存中；任何线程在释放monitor的第一时间，会先将缓存中的数据复制到共享内存中
	    保证线程间操作的有序性：synchronized的原子性保证了由其描述的方法或代码操作具有有序性，同一时间最多只能有一个线程访问，不会触发JMM指令重排机制
	    第二种：Volatile关键字-->保证变量的操作具有可见性和有序性
	    第三种：使用锁

    （1）使用线程安全的类；
	（2）使用synchronized同步代码块，或者用Lock锁；
	（3）多线程并发情况下，线程共享的变量改为方法局部级变量；

	7、synchronized与lock的区别：
		获取Lock对象的方法：Lock lock = new ReentrantLock();
		（1）首先synchronized是java内置关键字，在jvm层面，Lock是个java类；
		（2）synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；
		（3）synchronized会自动释放锁，Lock需在finally中手工释放锁（lock.unlock()方法释放锁），否则容易造成线程死锁；
		（4）用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；
		（5）synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）
		（6）Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。
		（7）Lock锁可以设置等待时间，到了时间自动放弃获取锁
总结：
    出现线程安全问题的原因：
    	在多个线程并发环境下，多个线程共同访问同一共享内存资源时，其中一个线程对资源进行写操作的中途，其他线程对这个写一半的资源进行读操作，或者对这个写了一半的资源进行了写操作，导致此资源出现的数据错误
    如何避免线程安全问题：
    	保证共享资源在同一时间只能由一个线程进行操作（原子性、有序性）
    	将线程操作的结果即使更新，保证其他线程可以立即获取到修改后的最新数据（可见性）
37、深拷贝和浅拷贝：
        浅拷贝：被复制的对象的所有的变量都与原对象有相同的值，而所有的引用对象仍然指向原来的对象，换言之，浅拷贝只是复制所拷贝的对象，不复制引用对象
        深拷贝：除了复制的对象的所有变量都有原来对象的值之外，还把引用对象也指向了被复制的新对象
38、jdbc链接数据库的6个步骤：
	1、加载JDBC驱动程序：在连接数据库之前，首先要加载想要链接的数据库的驱动到JVM（java虚拟机），这通过java.lang.class类的静态方法forName(String classname)实现
	2、创建数据库的连接：
		•要连接数据库，需要向java.sql.DriverManager请求并获得Connection对象，该对象就代表一个数据库的连接。    
    	•使用DriverManager的getConnectin(String url , String username ,  String password )方法传入指定的欲连接的数据库的路径、数据库的用户名和密码来获得。 
    	Statement stmt = con.createStatement() ;    
       	PreparedStatement pstmt = con.prepareStatement(sql) ;    
       	CallableStatement cstmt = con.prepareCall("{CALL demoSp(? , ?)}") ;    
    3、创建一个preparedStatement
    	  •要执行SQL语句，必须获得java.sql.Statement实例，Statement实例分为以下3 种类型：    
	      1、执行静态SQL语句。通常通过Statement实例实现。    
	      2、执行动态SQL语句。通常通过PreparedStatement实例实现。    
	      3、执行数据库存储过程。通常通过CallableStatement实例实现。  
    4、执行sql语句：
    	•Statement接口提供了三种执行SQL语句的方法：executeQuery 、executeUpdate和execute    
	    1、ResultSet executeQuery(String sqlString)：执行查询数据库的SQL语句，返回一个结果集（ResultSet）对象。    
	    2、int executeUpdate(String sqlString)：用于执行INSERT、UPDATE或 DELETE语句以及SQL DDL语句，如：CREATE TABLE和DROP TABLE等    
	    3、execute(sqlString):用于执行返回多个结果集、多个更新计数或二者组合的语句。  
	5、遍历结果集    
	    两种情况：    
	     1、执行更新返回的是本次操作影响到的记录数。    
	     2、执行查询返回的结果是一个ResultSet对象。    
	    • ResultSet包含符合SQL语句中条件的所有行，并且它通过一套get方法提供了对这些    
	      行中数据的访问。    
	    • 使用结果集（ResultSet）对象的访问方法获取数据：     
	6、处理异常，关闭JDBC对象资源     
     •操作完成以后要把所有使用的JDBC对象全都关闭，以释放JDBC资源，关闭顺序和声 明顺序相反：    
     1、先关闭requestSet    
     2、再关闭preparedStatement    
     3、最后关闭连接对象connection  
39、java web
	Controller（控制层）：后台总控bai制器，接收所有前台传过du来的请求，再把它分配到zhi它需要调的service里，相当于前后台的入口dao（Controller可以有多个，比如可以有10个不频繁访问的服务，可以用一个Controller来控制，另外两个访问频繁的用另一个Controller控制，分开均衡一点）
	Services（业务层）【应用层】：所有的逻辑在Services里，逻辑，算法，都是由Services构成的（可以理解成Services里面写核心算法，比如if,else，通过JAVA来实现逻辑的变化，数据的变化）一个按钮对应一个service，所有请求先到controller里面，然后再去找它要哪个服务，再创建一个对应的实例。（简单的项目也可以不用控制器，直接前台调services,但一般都会有一个控制器来管理一下服务的请求）
	Dao（持久层）：接口（应用层和数据层的接口），只定义对象，不定义具体的内容，之所以有Dao，是为了让Services可以直接用里面定义好的东西，没有Dao的话是调不到的，相当于是在Services里调的是一个接口，Spring运行的时候Spring和Mybatis实时在里面生成方法，实际生成的方法在jar包里面。每添加一个方法，一个SQL，要在Dao里添加一个接口的定义。通过Dao找Mapper文件下的同名的SQL语句，一个Dao对应一个Mapper
	Mapper【数据层】：写在xml文件里，里面写对应的SQL语句，实现在数据库中怎么查找。所有的xml都是配置文件，给程序去读取的
	Model：保存着与数据库表所对应的结构体，作用是方便用表的结构体，增加Mapper的易用性，把所有SQL字段变成变量放在里面，根据表结构自动生成  
39、java类型转换：
	小的到大的直接转
	大的到小的强制类型转换 
40、java精度：
	精度是指各种数据类型的位宽：
	byte:8位
	short:16位
	int:32位
	long:64位
	float:32位
	double:64位
	char :16位
	java进行浮点数运算的时候，会出现丢失精度的问题。解决：利用bigDecimal解决
38、单例模式：
		定义：是java中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳对象。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象
		性质：
			1、单例类只能有一个实例
			2、单例类必须自己创建自己的唯一实例
			3、单例类必须给所有其他对象提供这一实例
		意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。
		主要解决：一个全局使用的类频繁地创建与销毁。
		何时使用：当您想控制实例数目，节省系统资源的时候。
		如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。
		关键代码：构造函数是私有的	
	饿汉模式：
	public class EagerSingle{
			//饿汉模式单例
    		//在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度快
		private static EagerSingle single = new EagerSingle();

		private EagerSingle(){
			//私有构造方法
		}
		//静态，不用同步（类加载时已初始化，不会有多线程的问题）
		public static EagerSingle getInstance(){
			return single;  
		}
	}
	懒汉模式：
	public class LazySingleton {
    //懒汉模式单例
    //比较懒，在类加载时不创建实例，因此类加载熟读快，但运行时获取对象速度慢
    private static LazySingleton instance;//静态私有成员，没有初始化

    private LazySingleton() {
        //私有构造函数
    }

    public static synchronized LazySingleton getInstance() {//静态、同步、公开访问
        if (instance == null) {
            instance = new LazySingleton();
        }
        return instance;
    }
}

24、排序：
	（1）归并排序：

			「归并排序」是分治思想的典型应用，它包含这样三个步骤：
			分解： 待排序的区间为 [l, r]，令 m = (l + r) / 2  ，我们把 [l, r][l,r] 分成 [l, m]和 [m + 1, r]
			解决： 使用归并排序递归地排序两个子序列
			合并： 把两个已经排好序的子序列 [l, m] 和 [m + 1, r]合并起来，合并成一个最终的排序序列
			public static void main(String[] args){
				int[] array = {3,44,53,42,14,53,77,09};
				mergeSort(array);
			}
			//归并排序
			public static void mergeSort(int[] arr){
				if(arr== null || arr.length <= 1){
					return;
				}

				sort(arr, 0, arr.length-1);
			}

			//分为两个序列，递归分子序列，调用合并
			private static void sort(int[] arr, int left, int right){
				if(left == right){
					return;
				}
				int mid = (left + right) >>1;

				sort(arr, left, mid);
				sort(arr, mid+1, right);

				//合并
				merge(arr,left,mid,right);
			}

			private static void merge(int[] arr,int left,int mid,int right){
				int[] tmp =new int[right-left+1];
				
				int p1 = left;
				int p2 = mid+1;
				//比较左右两个部分的元素，哪个小，把那个元素填入tmp中
				int i = left;
				while(p1 <= mid && p2<= right){
					tmp[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
				}
				//上面的循环退出后，把剩余的元素依次填入到tmp中
				//下面两个while只有一个会执行
				while(p1 <= mid){
					tmp[i++] = arr[p1++];
				}
				while(p2 <= right){
					tmp[i++] = arr[p2++]
				}

				//把最终的排序结果赋值给原数组
				
				for(int j = left;j <= right;j++){
					arr[j] = tmp[j];
				}
			}
	（2）冒泡排序：
			比较相邻的元素。如果第一个比第二个大，就交换它们两个
			对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素就是最大的数
			针对所有的元素重复以上的工作，除了最后一个
			重复上诉过程，直到排序完成
			public static void bubbleSort(int[] arr){
				if(arr == null || arr.length <= 1){
					return;
				}
				int len = arr.length;
				for(int i = 0;i < len;i++){
					for(int j = 0;j < len-i-1;j++){
						if(arr[j] > arr[j+1]){
							int tmp = arr[j];
							arr[j] = arr[j+1];
							arr[j+1] = tmp;
						}
					}
				}
			}
	(3)//：
			从数列中挑出一个元素，称为基准
			重新排序数列，所有元素比基准小的放在基准的前面，所有元素比基准值大的摆在基准的后面（相同的可以放在任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区操作
			递归地把小于基准值元素的子数列和大于基准值元素的子数列排序
			public static void quickSort(int[] arr){
				sort(arr, 0, arr.length-1);
			}

			private static void sort(int[] arr, int left, int right){
				if(arr == null || left >= right || arr.length <= 1){
					return;
				}
				int mid = partition(arr,left,right);
				sort(arr,left,mid);
				sort(arr,mid+1,right);

			}

			private static int partition(int[] arr, int left,int right){
				int tmp = arr[left];

				while(left < right){
					//先判断基准数和后面的数依次比较
					while(left < right && tmp <= arr[right]){
						--right;
					}

					/当基准数大于了arr[left],则填坑
					if(left < right){
						arr[left] = arr[right];
						++left;
					}

					// 现在是arr[right]需要填坑了
					while(left < right && tmp >= arr[left]){
						++left;
					}
					if(left < right){
						arr[right] = arr[left];
						--right;
					}
					
				}
				arr[left] = tmp;
				return left;
			}
	（4）堆排序：
	构建初始堆，将待排序列构成一个大顶堆(或者小顶堆)，升序大顶堆，降序小顶堆；
	将堆顶元素与堆尾元素交换，并断开(从待排序列中移除)堆尾元素。
	重新构建堆。
	重复2~3，直到待排序列中只剩下一个元素(堆顶元素)。

	大顶堆原理：根结点（亦称为堆顶）的关键字是堆里所有结点关键字中最大者，称为大顶堆。大顶堆要求根节点的关键字既大于或等于左子树的关键字值，又大于或等于右子树的关键字值。
    小顶堆原理：根结点（亦称为堆顶）的关键字是堆里所有结点关键字中最小者，称为小顶堆。小堆堆要求根节点的关键字既小于或等于左子树的关键字值，又小于或等于右子树的关键字值。


    class HeapSort{
    	public static void main(String[] args){
    		int[] arr = {16,7,3,20,17,8};
    		heapSort(arr);
    		for(int num : arr){
    			System.out.print(num + " ");
    		}
    	}

    	//创建堆
    	private static void heapSort(int[] arr){
    		//创建堆
    		for(int i = (arr.length - 1) / 2 ; i >= 0;i--){
    			//从第一个非叶子结点从下到上，从右到左调整结构
    			adjustHeap(arr,i,arr.length);
    		}
    		//调整堆结构+交换栈顶元素与末尾元素
    		for(int i = arr.length - 1;i>0;i--){
    			//将栈顶元素与末尾元素进行交换
    			int tmp = arr[i];
    			arr[i] = arr[0];
    			arr[0] = tmp;

    			//重新对堆进行调整
    			adjustHeap(arr,0,i);
    		}
    	}

    	//调整堆 parent父节点 length待排序列尾元素索引
    	private static void adjustHeap(int[] arr,int parent,int length){
    		//将tmp作为父节点
    		int tmp = arr[parent];
    		//左孩子
    		int lchild = 2*parent + 1;

    		while(lchirld < length){
    			//右孩子
    			int rchirld = lchirld + 1;
    			//如果有右孩子结点，并且右孩子结点的值大于左孩子结点，则选取右孩子结点
    			if(rchild < length && arr[lchirld] < arr[rchirld]){
    				lchirld++;
    			}
    			//如果父节点的值已经大于孩子结点的值，则直接结束
    			if(tmp >= arr[lchild]){
    				break;
    			}

    			//把孩子结点的值赋给父节点
    			arr[parent] = arr[lchild];

    			//选取孩子结点的左孩子结点，继续向下筛选
    			parent = lchild;
    			lchild = 2 * lchild + 1;

    		}
    		arr[parent] = tmp;
    	}
    }
	(5)插入排序：
			从第一个元素开始，该元素可以认为已经被排序
			取出下一个元素，在已经排序的元素序列中从后往前向前扫描
			如果该元素大于新元素，将该元素移到下一个位置
			重复上诉操作，直到找到已排序的元素小于或者等于新元素的位置
			将新元素插入到该位置
			public static void insertSort(int[] arr){
				if(arr == null || arr.length <= 1){
					return;
				}

				int len = arr.length;

				int insertNum;
				for(int i =1 ;i < len;i++){
					insertNum = arr[i];

					int j = i-1;
					while(j >= 0 && arr[j] > insertNum){
						//从后向前扫描，将大于insertNum的数向后移动一格
						arr[j+1] = arr[j];
						j--;
					}

					//将需要插入的数放在要插入的位置
					arr[j+1] = insertNum;
				}
			}
	
多态案例：
public interface TimeSpeek {
	public abstract void getTimeSppek();
}

public class SpeekOne implements TimeSpeek {
	@Override
	public void getTimeSppek() {
		System.out.println("停车坐爱枫林晚");
	}
}

public class SpeekTwo implements TimeSpeek {
	@Override
	public void getTimeSppek() {
		System.out.println("霜叶红于二月花");
	}
}

public class Test {

	public static void main(String[] args) {
		TimeSpeek t1 = new SpeekOne();
		TimeSpeek t2 = new SpeekTwo();
		t1.getTimeSppek();
		t2.getTimeSppek();
	}

}


























