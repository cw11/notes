mySQL相关：

1、count():聚合函数，对于返回的结果集，一行行的判断，如果count函数的参数不是null，累计值就加一，否则不加
	count(*)、count(1)和count(主键 id) 都表示返回满足条件的结果集的总行数；而 count(字段），则表示返回满足条件的数据行里面，参数“字段”不为 NULL 的总个数。
	性能对比：count(可空字段) < count(非空字段) = count(主键 id) < count(1) ≈ count(*)
2、什么是事务？
	数据库中的事务是作为单个逻辑工作单元执行的一系列操作（多条sql语句，要么全部执行成功，要么全部执行失败）
3、数据库要支持事务操作必须满足4个特性，也就是常说的ACID：
	（1）原子性：原子性是指事务包含的所有操作要么全部成功，要么全部失败
	（2）一致性：一个事务执行之前和执行之后都必须处于一致性状态，只是数据从一个状态转移到另一个状态
	（3）隔离性：多个事务执行同一个操作时不能被其他事务干扰
	（4）持久性：一个事务一旦提交，它对数据库中数据的改变就应该是持久性的
4、什么是事务隔离，有哪些事务隔离级别
	事务的隔离性就是指，多个并发的事务同时访问一个数据库时，一个事务不应该被另一个事务所干扰，每个并发的事务间要相互进行隔离
	（1）读未提交：一个事务读到了另一个未提交事务的数据
	（2）读已提交：一个事务要等到另一个事务提交后才能读取数据
	（3）可重复读：开始读取数据（事务开启）时，不再允许修改操作
	（4）串行化：事务串行化顺序执行，也就是一个一个排队执行（每一行数据都进行了加锁）

	脏读：一个事务正在访问并修改了数据，另一个事务读到了它修改的还未提交的数据
	不可重复读：一个事务在多次读取数据时，由于另一个事务的修改，而读到的数据不一样
	幻读：一个事务对数据进行了修改，另一个事务插入了一条数据，第一个事务发现数据表中有一行没有修改的数据，但刚才明明已经全部改了，仿佛发生了幻觉一样

				    脏读         不可重复读          幻读
	读未提交：       可能              可能            可能
	读已提交：       不可能             可能           可能
	可重复读：       不可能           不可能         	可能
	串行化：         不可能           不可能           不可能
5、SQL中drop truncate delete的区别
	delete：每次从表中删除一行，并且同时将该行的删除操作作为事务记录保存在日志中以便进行回滚操作，delete操作不会减少表或索引所占用的空间
	truncate：一次性的删除表中的所有数据并且不把删除记录保存到日志中，是不能恢复的，并且在删除的过程中不会激活与表有关的删除触发器，执行速度快。这个表和索引所占用的空间会恢复到初始大小
	drop：删除整个表（包括结构和数据），释放整个表所占用的空间
6、innoDB和myISAM的区别：
	innoDB                  myISAM
	支持事务                 不支持事务
	支持行锁                 支持表锁
	支持外键                 不支持外键
	聚集索引                 非聚集索引
	索引和数据紧密联系        索引和数据分开
							强调性能
7、为什么使用b+树？
	1、B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了
	2、B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根节点到叶子节点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当
	3、由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。
8、数据库索引
	索引是什么？
		是对数据库表中一列或多列的值进行排序的一种结构，是一种加快海量数据查询的关键技术
	为什么数据库要使用索引？
		提高检索速度、加速表与表之间的连接
	索引的类型有哪些
		B树，B+树，B-树，哈希
	索引种类有哪些？
		普通索引，唯一索引，主键索引...
	索引的优点？
		（1）通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性
		（2）可以大大加快数据检索速度，这也是创建索引的最主要原因
		（3）可以加速表与表之间的连接
		（4）在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间
		（5）通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统性能
	索引的缺点？
		（1）创建索引和维护索引要耗费时间，这种时间随着数据量的增大而增大
		（2）索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要简历聚簇索引，那么需要的空间就会更大

9、什么时候需要创建索引？
	创建索引情况：
		（1）在经常需要搜索的列上，可以加快搜索速度
		（2）在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构
		（3）在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；
		（4）在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的
		（5）在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间
		（6）在经常使用where子句中的列上面创建索引，加快条件查询的判断速度
	不应该创建索引的情况：
		（1）对于那些在查询中很少使用或者参考的列不应该创建索引
		（2）对于那些只有很少数据值的列也不应该增加索引
		（3）对于那些定义为text image bit数据类型的列不应该增加索引
		（4）当修改性能远远大于检索性能时，不应该创建索引
10、索引在什么情况下会失效：
	1、对于创建的多列索引（复合索引），不是使用的第一部分就不会使用索引
	2、对于使用like查询，如果"%aaa"不会使用索引，"aaa%"会使用索引
	3、如果条件中有or,有条件没有使用索引，即使其中有条件带索引也不会使用，换言之，就是要求使用的所有字段，都必须单独使用时能使用索引
	4、如果列类型是字符串，那么一定要在条件中使用引号引用起来，否则不使用索引
	5、如果mysql认为全表扫描要比使用索引快，则不使用索引，比如表里只有一条数据
	6、条件中有null值
	7、where语句中有 not in, <> !=

10、优化数据库查询语句：
	（1）、优化索引、sql语句、分析慢查询
	（2）、设计表的时候严格根据数据的设计规范来设计数据库
	（3）、使用缓存，把经常访问到的数据而且不需要变化的数据放到缓存中
	（4）、使用固态硬盘
	（5）、采用MYSQL内部自带的表分区技术，把数据分层到不同的文件中，能够提高餐盘的读写效率
	（6）、垂直分表，把一些不经常用到的数据放到一个表中，节约磁盘的I/O
	（7）、主从分离读写，采取主从复制把数据库的读操作和写操作分离出来
	（8）、数据库分表分机器（数据特变大的），主要的原理就是数据路由
	（9）、选择合适的表引擎，对参数地上的优化
	（10）、进行加购级别的缓存，静态化和分布式。
	（11）、不采用全文索引吗，用什么搜什么
	（12）、采用更快的处分方式，例如NoSql储存经常访问的数据
10、左连接、右连接、内连接：
	左连接：left join ,左边表格的所有行都显示，右表中不存在的为null:
			select a.* b.* from a left join b on a.id = b.id
	右连接：right join ,右边表格的所有行都显示，左边中不存在的为null
			select a.*, b.* from a right join b on a.id = b.id
	内连接：inner join: 左右表中都存在的才显示
			select a.*,b.* from a inner join b on a.id = b.id
11、sql增删查改
	增：insert into 表名（字段）values (值)；
	删：delete from 表名 where 字段 = ‘值’；
	查：selest * from 表名 where...
	改：update 表名 set 字段1 = 值1 were... 
12、SQL的执行顺序：
	select
	from
	where 
	group by
	order by
13、去重：distinct
14、悲观锁和乐观锁：
	悲观锁：
		总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其他线程阻塞，用完后再把资源转让给其他线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁，读锁，写锁。java中synchronized和reentrantlock等独占锁就是悲观锁思想的实现
	乐观锁：
		总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。
	两种锁的使用场景
		从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适
15、mysql中s锁和x锁的区别：
        共享锁（S锁）：又称读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加x锁，直到事务T释放A上的S锁
            		这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改

        排他锁（X锁）：又称写锁，若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁
        			这保证了其他事务在T释放A上的锁之前不能再读取和修改A
16、行锁和表锁：
	行锁：会出现死锁，发生锁冲突几率低，并发高
		行锁必须有索引才能实现，否则会自动锁全表，那么就不是行锁了
		两个事务不能锁同一个索引
		insert delete update 在事务中都会自动默认加上排它锁
	表锁：不会出现
	死锁，发生锁冲突几率高，并发低
15、死锁：
	（1）什么是死锁：
		是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都无法向前推进
	（2）死锁产生的原因：
		1、系统资源的竞争：系统资源的竞争导致系统资源不足，以及资源分配不当，导致死锁
		2、进程运行推进顺序不合适：进程在运行过程中，请求和释放资源的顺序不当，会导致死锁
	（3）死锁产生的四个必要条件：
		互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待
		请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己以获得的资源保持不放
		不可剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放
		循环等待条件：若干进程间形成首尾相接循环等待资源的关系
	（4）死锁避免的思想：
		系统对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，如果分配后系统可能发生死锁，则不予分配，否则予以分配，这是一种保证系统不进入死锁状态的动态策略
	（5）如何将死锁减至最小：
            1、按同一顺序访问对象
            2、避免事务中的用户交互
            3、保持事务简短并在一个批处理中
            4、使用低隔离级别
            5、使用绑定连接
16、wait notify notifyAll区别：
	wait:被锁定对象调用wait方法时，这将导致当前线程被阻塞并放弃该对象的锁，即解除wait()方法的当前对象的锁定状态，其他线程就有机会访问该对象
	notify：使等待队列上的一个线程离开阻塞状态
	notifyAll:使等待队列上的所有线程离开阻塞状态
16、sql中视图和表的区别：
	1、性质不同：
		视图：视图不是一个独立的文件，是由一个或几个基本表导出形成的虚表
		表：表是数据库中用来存储数据的对象，是有结构的数据的集合，是整个数据库系统的基础
	2、存储内容不同：
		视图：存储的内容是来自本地数据源或远程数据源的定义，不存放实际数据
		表：表存储的内容是本地数据源的数据
	3、操作不同：
		视图：操作者只可以对视图进行查操作，不能进行增删查改操作
		表：操作者可以对表进行增删查改操作
17、数据库的三范式：
	第一范式：
		确保每列的原子性（强调的是列的原子性，即列不能够再分成其他几列），第一范式是所有关系型数据库的最基本要求（保证列的原子性）
    第二范式：
    	第二范式依赖第一范式，所以第二范式必须符合第一，然后第二范式需要确保数据库中每一列都和主键相关，而不能只与主键的某一部分相关（保证行的原子性）
    第三范式：
    	在第二范式的基础上更进一步，目标是确保每列都和主键列直接相关，而不是间接相关。（保证相关联的表与表之间没有冗余字段）

18、mysql中explain关键字的作用：
	模拟mysql优化器是如何执行sql查询语句的，从而知道mysql是如何处理你的sql语句。分析你的查询语句或是表结构的性能瓶颈
19、聚集索引和非聚集索引
	聚集索引：键值的逻辑顺序决定了表中相应行的物理顺序
	非聚集索引：记录的物理顺序与索引顺序可以不相同	
20、联合索引：即通过第一个字段的值（部首）在第一级索引中找到对应的第二级索引位置（检字表页码），然后在第二级索引中根据第二个字段的值（笔画）找到符合条件的数据所在的位置（险字的真正页码）
21、最左匹配原则：对于一个联合索引，如果有一个SQL查询语句需要执行，则只有从索引最左边的第一个字段开始到SQL语句查询条件中不包含的字段（不含）或范围条件字段（含）为止的部分才会使用索引进行加速。

19、数据库为什么用B+树
	数据库使用B+树肯定是为了提升查找效率。
	但是具体如何提升查找效率呢？
	查找数据，最简单的方式是顺序查找。但是对于几十万上百万，甚至上亿的数据库查询就很慢了。
	所以要对查找的方式进行优化，熟悉的二分查找，二叉树可以把速度提升到O(log(n,2))，查询的瓶颈在于树的深度，最坏的情况要查找到二叉树的最深层，由于，每查找深一层，就要访问更深一层的索引文件。在多达数G的索引文件中，这将是很大的开销。所以，尽量把数据结构设计的更为‘矮胖’一点就可以减少访问的层数。在众多的解决方案中，B-/B+树很好的适合。B-树定义具体可以查阅，简而言之就是中间节点可以多余两个子节点，而且中间的元素可以是一个域。相比B-树，B+树的父节点也必须存在于子节点中，是其中最大或者最小元素，B+树的节点只存储索引key值，具体信息的地址存在于叶子节点的地址中。这就使以页为单位的索引中可以存放更多的节点。减少更多的I/O支出。因此，B+树成为了数据库比较优秀的数据结构，MySQL中MyIsAM和InnoDB都是采用的B+树结构。不同的是前者是非聚集索引，后者主键是聚集索引，所谓聚集索引是物理地址连续存放的索引，在取区间的时候，查找速度非常快，但同样的，插入的速度也会受到影响而降低。聚集索引的物理位置使用链表来进行存储
20、数据库引擎
    当你访问数据库时，不管是手工访问还是程序访问，都不是直接读写数据库文件，而是通过数据库引擎去访问数据库文件。
    你发SQL语句给数据库引擎，数据库引擎解释SQL语句，提取出你需要的数据返回给你，因此，对访问者来说，数据库引擎就是SQL语句的解释器
21、索引在什么情况下会失效：
       1、 如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)
        注意：要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引
		2.对于多列索引，不是使用的第一部分，则不会使用索引
		3.like查询是以%开头
		4.如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引
		5.如果mysql估计使用全表扫描要比使用索引快,则不使用索引
22、怎么优化数据库？
		1、优化索引、sql语句、分析慢查询
		2、设计表的时候严格根据数据的设计规范来设计数据库
		3、使用缓存，把经常访问到的数据而且不需要变化的数据放到缓存中
		4、使用固态硬盘
		5、采用MYSQL内部自带的表分区技术，吧数据分层到不同的文件中，能够提高餐盘的读写效率
		6、垂直分表，吧一些不经常用到的数据放到一个表中，节约磁盘的I/O
		7、主从分离读写，采取主从复制把数据库的读操作和写操作分离出来
		8、数据库分表分机器（数据特变大的），主要的原理就是数据路由
		9、选择合适的表引擎，对参数地上的优化
		10、进行加购级别的缓存，静态化和分布式。
		11、不采用全文索引吗，用什么搜什么
		12、采用更快的处分方式，例如NoSql储存经常访问的数据
23、sql语句中explain关键字的作用：
    使用explain关键字可以模拟优化器执行SQL查询语句，从而知道MYSQL是如何处理你的SQL语句的，分析你的查询语句或是表结构的性能瓶颈
    通过explain我们可以获得以下信息：
            1、表的读取顺序
            2、数据读取操作的操作类型
            3、哪些索引可以使用
            4、哪些索引被实际使用
            5、表之间的引用
            6、每张表有多少行被优化器查询
24、char和varchar类型的区别：
    1、char的长度是不可变的，varchar的长度可变
    2、char的存取速度要比varchar快很多，因为其长度固定，方便程序的存储与查找
    3、char的存储方式是：英文字符占用1个字节，汉字占用2个字节；varchar的存储方式：英文字符占用2个字节，汉字也占用2个字节
    两者的应用场景：
        char:
            1、适合存储长度近似的值
            2、适合存储短字符串
            3、适合存储经常更新的字符串列
        varchar：
            1、字符串的最大长度比平均长度大很多
            2、字符串列很少被更新
25、SQL注入：
	什么是SQL注入？
		是一种将sql代码添加到输入参数中，传递到sql服务器解析并执行的一种攻击手法
	SQL注入是如何产生的？
		1、web开发人员无法保证所有的输入都已经过滤
		2、攻击者利用发送给sql服务器的输入数据构造可执行代码
		3、数据库未作相应的安全配置（对web应用设置特定的数据库账号，而不使用root或管理员账号，特定数据库账号给予一些简单操作的权限，回收一些类似drop的操作权限）
	如何寻找sql注入漏洞？
		1、识别web应用中所有输入点
		2、了解哪些类型请求会触发异常
		3、检测服务器响应中的异常
	如何进行sql注入攻击？
		数字注入
		字符串注入
	如何预防sql注入？
		1、严格检查输入变量的类型和格式
			（1）对数字类型的参数id的强校验（empty()为空校验和is_numeric（）进行数字校验）
			（2）对字符串类型的参数的校验（正则校验）
		2、过滤和转义特殊字符
		3、利用预编译机制
26、redis数据类型：
	string
	list
	hash
	set
	zset(sorted set:有序集合)
27、	使用Redis有哪些好处？
	(1) 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)
	(2) 支持丰富数据类型，支持string，list，set，sorted set，hash
	(3) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行
	(4) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除
28、redis是单线程还是多线程？
	执行redis命令的核心模块是单线程的




















