算法题

链表相关

1、奇偶链表：给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。
/*创建两个链表，一个初始为head，一个初始为head.next
一个连接奇节点，一个连接偶节点
再把两个链表连在一起*/
 public class ListNode {
      int val;
      ListNode next;
      ListNode() {}
      ListNode(int val) { this.val = val; }
      ListNode(int val, ListNode next) { this.val = val; this.next = next; }
  }
  class Solution{
  	public ListNode oddEvenList(ListNode head){
  		if(head == null || head.next == null){
  			return head;
  		}
  		ListNode point1 = head; 
  		ListNode point2 = head.next;

  		ListNode p1 = point1;
  		ListNode p2 = point2;
  		//根据奇偶分为两个链表
  		while(p2 != null && p2.next != null){
  			p1.next = p1.next.next;
  			p2.next = p2.next.next;
  			p1 = p1.next;
  			p2 = p2.next;
  		}
  		//将两个链表连起来
  		p1.next = point2;
  		return point1;
  	}
  }

2、分割链表:编写程序以 x 为基准分割链表，使得所有小于 x 的节点排在大于或等于 x 的节点之前。如果链表中包含 x，x 只需出现在小于 x 的元素之后(如下所示)。分割元素 x 只需处于“右半部分”即可，其不需要被置于左右两部分之间。
class Solution{
	public ListNode partition(ListNode head,int x){
		ListNode oneList = new ListNode(0);
		ListNode twoList = new ListNode(0);

		ListNode one = oneList;
		ListNode two = twoList;

		while(head != null){
			if(head.val < x){
				one.next = head;
				one = one.next;
			}else{
				two.next = head;
				two = two.next;
			}

			head = head.next;
		}
		two.next = null;
		one.next = twoList.next;
		return oneList.next;
	}
}

3、链表相交：给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同），则这两个链表相交。
public class Solution{
	public ListNode getIntersectionNode(ListNode headA,ListNode headB){
		ListNode p1 = headA;
		ListNode p2 = headB;

		while(p1 != p2){
			p1 = p1 == null ? headB:p1.next;
			p2 = p2 == null ? headA:p2.next;
		}
		return p1;
	}
}

4、返回倒数第k个节点：实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。
class Solution{
	public int KthToLast(ListNode head ,int k){
		ListNode fast = head;
		ListNode slow = head;

		for(int i = 0;i < k;i++){
			if(fast == null){
				return null;
			} 
			fast = fast.next;
		}
		while(fast != null){
			fast = fast.next;
			slow = slow.next;
		}
		return slow.val;
	}
}

5、删除链表中的节点：请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。
class Solution{
	public void deleteNode(ListNode node){
		node.val = node.next.val;
		node.next = node.next.next;
	}
}

6、从链表中删去总和值为0的连续节点：给你一个链表的头节点 head，请你编写代码，反复删去链表中由 总和值为 0 的连续节点组成的序列，直到不存在这样的序列为止。
删除完毕后，请你返回最终结果链表的头节点。
输入：head = [1,2,3,-3,4]
输出：[1,2,4]
/*
使用map存每个节点的和值以及链表节点
遍历两遍，第一遍存信息，第二遍删除相同sum之间的节点
*/
class Solution{
	public ListNode removeZeroSublist(ListNode head){
		ListNode dummy = new ListNode(0);
		dummy.next = head;

		int sum = 0;
		Map<Integer,ListNode> map = new HashMap<>();
		//第一次循环，将各个节点的值装在map集合中
		for(ListNode d = dummy;d != null;d = d.next){
			sum += d.val;
			map.put(sum,d);
		}

		//第二次遍历，若当前节点处sum在下一处出现，则说明中间这俩节点中间的和为0
		sum = 0;
		for(ListNode d = dummy;d!= null;d = d.next){
			sum += d.val;
			d.next = map.get(sum).next;
		}
		return dummy.next;
	}
	
}

7、k个一组翻转链表：给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。
给你这个链表：1->2->3->4->5
当 k = 2 时，应当返回: 2->1->4->3->5
当 k = 3 时，应当返回: 3->2->1->4->5
/*
使用栈，存放k个节点
往里存k个元素
如果不够就直接返回
pre连接栈中弹出的节点
弹完之后pre连接到cur节点
*/
class Solution{
	public ListNode reverseKGroup(ListNode head,int k){
		if(head == null){
			return null;
		}
		Stack<ListNode> stack = new Stack<>();
		ListNode dummy = new ListNode(0);
		dummy.next = head;
		ListNode pre = dummy;
		ListNode cur = dummy.next;
		while(cur != null){
			for(int i = 0;i<k && cur != null;i++){
				stack.push(cur);
				cur = cur.next;
			}
			if(stack.size() != k){
				return dummy.next;
			}
			while(stack.size != 0){
				pre.next = stack.pop();
				pre = pre.next;
			}
			pre.next = cur;
		}
		return dummy.next;
	}
}
8、删除排序链表中的重复元素1：给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。
输入: 1->1->2->3->3
输出: 1->2->3
class Solution{
	pubilc ListNode deleteDuplicates(ListNode head){
		ListNode cur = head;
		while(cur != null && cur.next != null){
			if(cur.val == cur.next.val){
				cur = cur.next.next;
			}else{
				cur = cur.next;
			}
		}
		return head;

	}
}

8、删除排序链表中的重复元素2：给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。
输入: 1->2->3->3->4->4->5
输出: 1->2->5
/*
创建虚拟头节点,pre,cur
如果前一个等于后一个节点的值
while都删除重复的节点
跳出来cur后移
pre连接cur
如果不等的话pre cur直接就往后移
*/
class Solution{
	public ListNode deleteDuplicates(ListNode head){
		ListNode dummy = new ListNode(0);
		dummy.next = head;
		ListNode pre = dummy;
		ListNode cur = dummy.next;
		while(cur != null){
			if(cur.next != null && cur.val == cur.next.val){
				while(cur.next != null && cur.val == cur.next.val){
					cur = cur.next;
				}
				cur = cur.next;
				pre.next = cur;
			}else{
				pre = cur;
				cur = cur.next;
			}

		}
		return dummy.next;
	}
}

9、移除重复节点：编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。
 输入：[1, 2, 3, 3, 2, 1]
 输出：[1, 2, 3]
 /*
 未排序的链表就使用set
 能添加进去就往后移一个
 不能添加进去就说明是重复的，就往后跳两个
 */
 class Solution {
    public ListNode removeDuplicateNodes(ListNode head) {
    	Set<Integer> set = new HashSet<>();
    	ListNode cur = head;
    	while(cur.next != null){
    		if(set.add(cur.val)){
    			cur = cur.next;
    		}else{
    			cur = cur.next.next;
    		}
    		
    	}
    	cur.next = null;
    	return head;


    }
}

9、环形链表2：给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。
/*
利用set的属性
遇到不能添加进去的节点就说明有环
遍历完就说明没有环
*/
public class Solution{
	public ListNode deleteCycle(ListNode head){
		Set<ListNode> set = new HashSet<>();
		ListNode cur = head;
		while(cur != null){
			if(set.contains(cur)){
				return cur;
			}else{
				set.add(cur);
				cur = cur.next;
			}
		}
		return null;
	}
}

//利用双指针
public class Solution{
	public ListNode detectCycle(ListNode head){
		ListNode fast = head;
		ListNode slow = head;

		while(fast != null && fast.next != null){
			slow = slow.next;
			fast = fast.next.next;
			if(slow == fast){
				ListNode slow2 = head;
				while(slow2 != slow){
					slow2 = slow2.next;
					slow = slow.next;
				}
				return slow;
			}
		}
		return null;
	}
}

10、删除中间节点：实现一种算法，删除单向链表中间的某个节点（即不是第一个或最后一个节点），假定你只能访问该节点。
输入：单向链表a->b->c->d->e->f中的节点c
结果：不返回任何数据，但该链表变为a->b->d->e->f
/*
创建虚拟头节点
要删除的节点的值被后一个覆盖就完事了
*/
class Solution{
	public void deleteNode(ListNode node){
		ListNode dummy = new ListNode(0);
		dummy.next = node;
		node.val = node.next.val;
		node.next = node.next.next;
	}
}

11、排序链表：在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。--归并
输入: 4->2->1->3
输出: 1->2->3->4
/*
采用归并排序的思想
先找到中间结点，分成两个链表，递归分split
比较两个链表依次填入到新链表中merge
*/
class Solution{
	public ListNode sortList(ListNode head){
		return head == null?null:splitList(head);
	}

	//分成两个链表:快慢指针
	public ListNode splitList(ListNode head){
		if(head.next == null){
			reuturn head;
		}
		ListNode fast = head;
		ListNode slow = head;
		ListNode pre = null;
		while(fast != null && fast.next != null){
			fast = fast.next.next;
			slow = slow.next
			pre = slow;
		}
		pre.next = null;
		ListNode l = splitList(head);
		ListNode r = splitList(pre);

		return merge(l,r)
	}

	//将两个链表排序
	public ListNode merge(ListNode l1,ListNode l2){
		ListNode dummy = new ListNode(0);
		ListNode cur = dummy;
		while(l1 != null && l2 != null){
			if(l1.val < l2.val){
				cur.next = l1;
				l1 = l1.next;
			}else{
				cur.next = l2;
				l2 = l2.next;
			}
			cur = cur.next;
		}
		cur.next = l1 == null ? l2:l1;
		return dummy.next;
	}
}

12、从尾到头打印链表：输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。
class Solution{
	public int[] reversePrint(ListNode head){
		Stack<Integer> stack = new Stack<>();
		while(head != null){
			stack.push(head.val);
			head = head.next;
		}
		int size = stack.size();
		int[] res = new int[size];
		int i = 0;
		while(!stack.isEmpty()){
			res[i++] = stack.pop();
		}
		return res;
	}
}

13、两数相加：给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807
class Solution{
	public ListNode addTwoNumbers(ListNode l1,ListNode l2){
		ListNode dummy = new ListNode(0);
		ListNode cur = dummy;
		int flag = 0;

		while(l1 != null || l2 != null || flag > 0){
			if(l1 != null){
				flag += l1.val;
				l1 = l1.next;
			}
			if(l2 != null){
				flag += l2.val;
				l2 = l2.next;
			}
			cur.next = new ListNode(flag % 10);
			flag /= 10;
			cur = cur.next;
		}

		return dummy.next;
	}
}

两数相加 II
给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。
输入：(7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 8 -> 0 -> 7
//注意这里是头插法
class Solution{
	public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
		Stack<Integer> stack1 = new Stack<>();
		Stack<Integer> stack2 = new Stack<>();
		while(l1 != null){
			stack1.push(l1.val);
			l1 = l1.next;
		}
		while(l2 != null){
			stack2.push(l2.val);
			l2 = l2.next;
		}
		int flag = 0;
		ListNode head = null;
		while(!stack1.isEmpty() || !stack2.isEmpty() || flag >0){
			int sum = flag;
			sum += stack1.isEmpty()?0:stack1.pop();
			sum += stack2.isEmpty()?0:stack2.pop();

			
			ListNode node = new ListNode(sum % 10);
			//头插法
			node.next = head;
			head = node;
			flag /= 10;

		}
		return head;

    }
}

14、回文链表：编写一个函数，检查输入的链表是否是回文的。
class Solution {
    //比较两个链表
    public boolean isPalindrome(ListNode head) {
        ListNode mid = this.findMiddle(head);
        ListNode two = this.reverse(mid);

        while(head != null && two != null){
            if(head.val != two.val){
                return false;
            }else{
                head = head.next;
                two = two.next;
            }
        }
        return true;


    }
    //找到链表的中点,并切分为两个链表
    private ListNode findMiddle(ListNode head){
        ListNode fast = head;
        ListNode slow = head;
        while(fast != null && fast.next != null){
            fast = fast.next.next;
            slow = slow.next;
        }
        
        
        return slow;
    }

    ////反转后面一个链表
    private ListNode reverse(ListNode head){
        ListNode pre = null;
        ListNode cur = head;
        while(cur != null){
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
}

15、重排链表,给定一个单链表 L：L0→L1→…→Ln-1→Ln ，将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
给定链表 1->2->3->4->5, 重新排列为 1->5->2->4->3.
class Solution{
	public void reorderList(ListNode head) {
		if(head == null || head.next == null || head.next.next == null){
			return;
		}
		//快慢指针，切分成两个链表
		ListNode slow = head;
		ListNode fast = head;
		while(fast.next != null && fast.next.next != null){
			slow = slow.next;
			fast = fast.next.next;
		}
		ListNode newHead = slow.next;
		slow.next = null;

		//反转链表
		newHead = reverseList(newHead);

		//合并两个链表
		while(newHead != null){
			ListNode tmp = newHead.next;
			newHead.next = head.next;
			head.next = newHead;
			head = newHead.next;
			newHead = tmp;
		}
        
    }
    public ListNode reverseList(ListNode head){
    	if(head == null){
    		return head;
    	}
    	ListNode pre = null;
    	ListNode cur = head;
    	while(cur != null){
    		ListNode next = cur.next;
    		cur.next = pre;
    		pre = cur;
    		cur = next;

    	}
    	return pre;

    }
}

16、合并两个有序链表：将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4
class Solution{
	public ListNode mergeList(ListNode l1, ListNode l2){
		if(l1 == null) return l2;
		if(l2 == null) return l1;
		ListNode dummy = new ListNode(0);
		ListNode cur = dummy;
		while(l1 != null || l2 != null){
			if(l1.val < l2.val){
				cur.next = l1;
				l1 = l1.next;
			}else{
				cur.next = l2;
				l2 = l2.next;
			}
			cur = cur.next;
		}
		cur.next = l1 == null ? l2:l1;
		return dummy.next;
	}
}

17、相交链表，编写一个程序，找到两个单链表相交的起始节点。
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    	ListNode p1 = headA;
    	ListNode p2 = headB;

    	while(p1 != p2){
    		p1 = p1 == null ? headB : p1.next;
    		p2 = p2 == null ? headA : p2.next;
    	}
        return p1;
    }
}

18、反转链表：定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
class Solution {
    public ListNode reverseList(ListNode head) {
    	
    	ListNode pre = null;
    	ListNode cur = head;
    	while(cur != null){
    		ListNode next = cur.next;
    		cur.next = pre;
    		pre = cur;
    		cur = next;
    	}
    	return pre;
    }
}

19、反转链表2：反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。
输入: 1->2->3->4->5->NULL, m = 2, n = 4
输出: 1->4->3->2->5->NULL
class Solution {
    public ListNode reverseBetween(ListNode head, int m, int n) {
    	ListNode dummy = new ListNode(0);
    	dummy.next = head;
    	ListNode pre = dummy;
    	for(int i = 1;i < m;i++){
    		pre = pre.next;
    	}
    	head = pre.next;
    	for(int j = m;j < n;j++){
    		ListNode next = head.next;
    		head.next = next.next;
    		next.next = pre.next;
    		pre.next = next;
    	}
    	return dummy.next;
    }
}

20、链表的中间节点：给定一个带有头结点 head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。
输入：[1,2,3,4,5]
输出：此列表中的结点 3 (序列化形式：[3,4,5])
class Solution {
    public ListNode middleNode(ListNode head) {
    	ListNode slow = head;
    	Listnode fast = head;
    	while(fast != null && fast.next != null){
    		slow = slow.next;
    		fast = fast.next.next;
    	}
    	return slow;

    }
}

21、移除元素：删除链表中等于给定值 val 的所有节点。
输入: 1->2->6->3->4->5->6, val = 6
输出: 1->2->3->4->5
/*
创建虚拟头节点，要删除不止一个
*/
class Solution {
    public ListNode removeElements(ListNode head, int val) {
    	ListNode dummy = new ListNode(0);
    	dummy.next = head;
    	ListNode cur = dummy;
    	
    	while(cur.next != null){
    		if(cur.next.val == val){
    			cur.next = cur.next.next;
    		}else{
    			cur = cur.next;
    		}
    	}
    	return dummy.next;

    }
}

22、删除链表的节点：给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。
输入: head = [4,5,1,9], val = 5
输出: [4,1,9]
/*
只需要删除一个节点
不等的时候就往后移
等的时候直接跳出来跳过一个节点
*/
class Solution{
	public ListNode deleteNode(ListNode head, int val) {
		if(head == null){
			return head;
		}
		if(head.val == val){
			return head.next;
		}
		ListNode pre = null;
		ListNode cur = head;
		while(cur != null && cur.val != val){
			pre = cur;
			cur = cur.next;
		}
		pre.next = cur.next;
		return head;
	}
}

23、环形链表：给定一个链表，判断链表中是否有环。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。
public class Solution {
    public boolean hasCycle(ListNode head) {
    	Set<Integer> set = new HashSet<>();
    	ListNode cur = head;
    	while(cur != null){
    		if(set.contains(cur.val)){
    			return true;
    		}else{
    			set.add(cur.val);
    		}
    		cur = cur.next;
    	}
    	return false;
        
    }
}

24、 删除链表的倒数第N个节点：给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。
给定一个链表: 1->2->3->4->5, 和 n = 2.
当删除了倒数第二个节点后，链表变为 1->2->3->5.
/*
快慢指针
slow.next = slow.next.next
*/
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
   		ListNode slow = head;
        ListNode fast = head;
        for(int i = 0;i<n;i++){
            fast = fast.next;
        }
        //如果n的值等于链表的长度，直接返回去掉头结点的链表
        if(fast == null){
              return head.next;
         }
        while(fast.next != null){
            fast = fast.next;
            slow = slow.next;
        }
        slow.next = slow.next.next;
        return head;
    }
}

25、两两交换链表中的节点：给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
给定 1->2->3->4, 你应该返回 2->1->4->3.
/*
创建虚拟头节点
cur
one two
*/
class Solution {
    public ListNode swapPairs(ListNode head) {
    	ListNode dummy = new ListNode(0);
    	dummy.next = head;

    	ListNode cur = dummy;
    	while(cur.next != null && cur.next.next != null){
    		ListNode one = cur.next;
    		ListNode two = cur.next.next;
    		one.next = two.next;
    		two.next = one;
    		cur.next = two;
    		cur = cur.next.next;
    	}
    	return dummy.next;
    }
 }

26、 旋转链表：给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。
输入: 1->2->3->4->5->NULL, k = 2
输出: 4->5->1->2->3->NULL
解释:
向右旋转 1 步: 5->1->2->3->4->NULL
向右旋转 2 步: 4->5->1->2->3->NULL
/*
先求出链表的长度
需要旋转的步数n为k% 链表长度
将链表首尾相连
循环找到第count-k就是新链表的头节点
断开
*/
class Solution {
    public ListNode rotateRight(ListNode head, int k) {
    	if(head == null || head.next == null || k == 0){
    		return head;
    	}
    	int count = 1;
    	ListNode tmp = head;
    	while(tmp.next != null){
    		count++;
    		tmp = tmp.next;
    	}
    	k %= count;
    	//先将链表收尾相连
    	tmp.next = head;
    	//找到第k个点
    	for(int i = 0;i < count - k;i ++){
    		tmp = tmp.next;
    	}
    	ListNode newHead = tmp.next;
    	tmp.next = null;
    	return newHead; 
    }
}

# 合并k个排序链表组合成一个排序链表
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
//利用小根堆，默认是放大的
每次 O(logK)O(logK) 比较 K个指针求 min, 时间复杂度：O(NlogK)
class Solution{
	public ListNode mergeKlists(ListNode[] lists){
		Queue<ListNode> pq = new PriorityQueue<>((v1,v2) -> v1.val - v2.val);
		for(ListNode node : lists){
			if(node != null){
				pq.offer(node);
			}
		}

		ListNode dummy = new ListNode(0);
		ListNode tail = dummy;
		while(!pq.isEmpty()){
			ListNode node = pq.poll();
			tail.next = node;
			tail = node;
			if(node.next != null){
				pq.offer(node.next);
			}
		} 
		return dummy.next;
	}
}

二叉树相关：

1、二叉树的层序遍历：给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。
二叉树：[3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回其层次遍历结果：

[
  [3],
  [9,20],
  [15,7]
]
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
	def levelOrder(self, root:TreeNode):
		res = []
		queue = [root]
		while queue:
			tmp = []
			for i in range(len(queue)):
				cur = queue.pop(0)
				tmp.append(cur.val)
				if cur.left:
					queue.append(cur.left)
				if cur.right:
					queue.append(cur.right)
			if tmp:
				res.append(tmp)
		return res

2、检查平衡性：实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个节点，其两棵子树的高度差不超过 1。
class Solution:
	# 求左右二叉树的高度
	def getDepth(self,root:TreeNode):
		if not root:
			return 0
		return 1+ max(self.getDepth(root.left), self.getDepth(root.right))

	def isBalance(self,root:TreeNode):
		if not root:
			return True
		if abs(self.getDepth(root.left) - self.getDepth(root.right) ) > 1:
			return False
		return isBalance(root.left) and isBalance(root.right)

3、对称二叉树：给定一个二叉树，检查它是否是镜像对称的。
//check(root,root)
class Solution:
	def isSymmetric(self,root):

		def check(node1,node2):
			if not node1 and not node2:
				return True
			elif not node1 or not node2:
				return False
			if node1.val != node2.val:
				return False
			return check(node1.left,node2.right) and check(node1.right, node2.left)

		return check(root,root)
4、二叉树的镜像：
//交换
class Solution:
	def mirrorTree(self,root:TreeNode):
		if not root:
			return None
		tmp = root.left
		root.left = self.mirrorTree(root.right)
		root.right = self.mirrorTree(tmp)
		return root
5、合并二叉树：给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。
//将t2的值加到t1上，左右子树递归
class Solution:
	def mergeTree(self,t1:TreeNode,t2:TreeNode):
		if not t1:
			return t2
		if not t2:
			return t1
		t1.val += t2.val
		t1.left = self.mergeTree(t1.left,t2.left)
		t1.right = self.mergeTree(t1.right,t2.right)
		return t1	

6、路径总和，给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。
给定如下二叉树，以及目标和 sum = 22，

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1

class Solution:
    def hasPathSum(self, root: TreeNode, sum: int) -> bool:
    	if not root:
    		return False
    	# 终止条件
    	if not root.left and not root.right:
    		return sum - root.val == 0
    	return self.hasPathSum(root.left,sum - root.val) or self.hasPathSum(root.right,sum-root.val)

7、路径总和 II，给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。说明: 叶子节点是指没有子节点的节点。
示例:
给定如下二叉树，以及目标和 sum = 22，

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
返回:
[
   [5,4,11,2],
   [5,8,4,5]
]

class Solution:
    def pathSum(self, root: TreeNode, sum: int) -> List[List[int]]:
    	res = []
    	tmp = []
    	def dfs(node,sum):
    		if not node:
    			return
    		else:
    			# 添加一个可能的值
    			tmp.append(node.val)
    			sum -= node.val
    			# 终止条件：到叶子节点且和为0
    			if not node.left and not node.right and not sum:
    				res.append(tmp[:])
    			dfs(node.left,sum)
    			dfs(node.right,sum)
    			#回溯
    			tmp.pop()
    	dfs(root,sum)
    	return res

8、I. 二叉搜索树的最近公共祖先给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]
示例 1:
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
    	if root.val > p.val and root.val > q.val:
    		return self.lowestCommonAncestor(root.left,p,q)
    	if root.val < p.val and root.val <q.val:
    		return self.lowestCommonAncestor(root.right,p,q)
    	return root

9、II. 二叉树的最近公共祖先，给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]
示例 1:
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
class solution:
	def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
		if not root:
			return None
		left = self.lowestCommonAncestor(root.left,p,q)
		right = self.lowestCommonAncestor(root.right,p,q)
		# 一个在左，一个在右
		if left and right:
			return root
		# 两个都在左
		if left:
			return left
		# 两个都在右
		if right:
			return right
		return None
10、输入某一数组，判断是否是某二叉搜索数的后序遍历结果
class Solution:
	def ispostOrder(self,postorder):
        def helper(nums):
            if len(nums) <= 1: 
                return True
            root = nums[-1]
            for i in range(len(nums)):
                if nums[i] > root:
                    break
            for j in range(i, len(nums)-1):
                if nums[j] < root:
                    return False
            return helper(nums[:i]) and helper(nums[i:-1])
        
        if not postorder: return True
        return helper(postorder)



4、二叉树的最大深度，给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。说明: 叶子节点是指没有子节点的节点。
class Solution:
	def getMaxDepth(self,root:TreeNode):
		if not root:
			return 0
		left = self.getMaxDepth(root.left)
		right = self.getMaxDepth(root.right)
		return 1+max(left,right)
5、二叉树的最小深度：给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
class Solution:
	def getMinDepth(self,root:TreeNode):
		if not root:
			return 0
		if not root.left and root.right:
			return 1+self.getMinDepth(root.right)
		if not root.right and root.left:
			return 1+self.getMinDepth(root.left)
		return 1+min(self.getMinDepth(root.left), self.getMinDepth(root.right))


5、二叉树的直径：给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。
class Solution:
	res = 0
	def diameterOfBinaryTree(self, root:TreeNode):
		def dfs(node):
			if not node:
				return 0
			l = dfs(node.left)
			r = dfs(node.right)
			self.res = max(self.res, r+l)
			# 返回此节点的高度给上一层
			return max(r,l)+1
		if not root:
			return 0
		dfs(root)
		return self.res



5、树的子结构：输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)，B是A的子结构， 即 A中有出现和B相同的结构和节点值。
class Solution:
	def judge(self,A,B):
		if not B:
			return True
		if not A:
			return False
		if A.val != B.val:
			return False
		return self.judge(A.left,B.left) and self.judge(A.right,B.right)

	def isSubTree(self,A:TreeNode,B:TreeNode):
		if not A or not B:
			return False
		if self.judge(A,B):
			reutrn True
		return self.isSubTree(A.left , B) or self.isSubTree(A,right, B)

6、给定两个二叉树，编写一个函数来检验它们是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。
输入:      1          1
          /           \
         2             2

        [1,2],     [1,null,2]

输出: false
class Solution:
	def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
		if not p and not q:
			return True
		elif not p or not q:
			return False
		elif p.val != q.val:
			return False
		else:
			return self.isSameTree(q.lef,p.left) and self.isSameTree(q.right,p.right)

6、二叉树的右视图：给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
输入: [1,2,3,null,5,null,4]
输出: [1, 3, 4]
解释:

   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---

class Solution:
	def rightSideView(self, root: TreeNode) -> List[int]:
		if not root:
			return []
		res = []
		queue = [root]
		while queue:
		
			for i in range(len(queue)):
				cur = queue.pop(0)
				if i == len(queue) - 1:
					res.append(cur)
				if cur.left:
					queue.append(cur.left)
				if root.right:
					queue.append(cur.right)
		return res

7、从上到下打印二叉树1：
    3
   / \
  9  20
    /  \
   15   7
返回：
[3,9,20,15,7]

class Solution:
	def levelOrder(self,root:TreeNode):
		if not root:
			return []
		res = []
		queue = [root]
		while queue:
			for i in range(len(queue)):
				cur = queue.pop(0)
				res.append(cur.val)
				if cur.left:
					queue.append(cur.left)
				if cur.right:
					queue.append(cur.right)
		return res

8、 从上到下打印二叉树 II：从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。
    3
   / \
  9  20
    /  \
   15   7
返回其层次遍历结果：

[
  [3],
  [9,20],
  [15,7]
]

class Solution:
	def levelOrder(self, root: TreeNode) -> List[List[int]]:
		if not root:
			return []
		res = []
		queue = [root]
		while queue:
			level = []
			for i in range(len(queue)):
				cur = queue.pop(0)
				level.append(cur.val)
				if cur.left:
					queue.append(cur.left)
				if cur.right:
					queue.append(cur.right)
			if level:
				res.append(level)
		return res

9、从上到下打印二叉树 III，请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。
    3
   / \
  9  20
    /  \
   15   7
返回其层次遍历结果：

[
  [3],
  [20,9],
  [15,7]
]
class Solution:
	def levelOrder(self, root: TreeNode) -> List[List[int]]:
		if not root:
			return []
		res = []
		queue = [root]
		level = 1
		while queue:
			tmp = []
			out = []
			for i in range(len(queue)):
				cur = queue.pop(0)
				tmp.append(cur.val)
				if level % 2 == 1:
					if cur.right:
						out.append(cur.right)
					if cur.left:
						out.append(cur.left)
				else:
					if cur.left:
						out.append(cur.left)
					if cur.right:
						out.append(cur.right)
			if tmp:
				res.append(tmp)
			queue = out
			level += 1
		return res

10、重建二叉树：输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：

    3
   / \
  9  20
    /  \
   15   7

class Solution:
	def buildTree(self,preOrder,inOder):
		if not preOder or not inOrder:
			return None
		local = inOrder.index(preOrder[0]
		root = TreeNode(preOrder[0]）

		root.left = self.buildTree(self,preOrder[1:local+1], inOrder[:local])
		root.right = self.buildTree(self, preOrder[local+1:], inOrder[local:])

		return root

11、二叉树的后序遍历：给定一个二叉树，返回它的 后序 遍历。
输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [3,2,1]
# 递归 后序：左右根
class Solution:
	def postOrder(self,root:TreeNode):
		def dfs(node):
			if not node:
				return []
			if node.left:
				dfs(root.left)
			if node.right:
				dfs(root.right)
			res.append(node.val)
		res = []
		dfs(root)
		return res
# 迭代
class Solution:
	def postOrder(self,root:TreeNode):
		if not root:
			return []
		res = []
		stack = [root]
		while stack:
			cur = stack.pop()
			res.append(cur.val)
			if cur.left:
				stack.append(cur.left)
			if cur.right:
				stack.append(cur.right)
		return res[::-1]

12、二叉树的前序遍历:给定一个二叉树，返回它的 前序 遍历。
输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [1,2,3]根左右
class Solution:
	def preOrder(self,root:TreeNode):
		def dfs(node):
			if not node:
				return []
			res.append(node.val)
			if node.left:
				dfs(node.left)
			if node.right:
				dfs(node.right)
		res = []
		dfs(root)
		return res

class Solution:
	def preOrder(self,root:TreeNode):
		if not root:
			return []
		res = []
		stack = [root]
		while stack:
			cur = stack.pop()
			if cur:
				res.append(cur.val)
				if cur.right:
					stack.append(cur.right)
				if cur.left:
					stack.append(cur.left)
		return res

13、二叉树的中序遍历：给定一个二叉树，返回它的中序 遍历。
输入: [1,null,2,3]
   1
    \
     2
    /
   3

输出: [1,3,2]左根右
class Solution:
	def inOrder(self,root:TreeNode):
		def dfs(node):
			if not node:
				return []
			if node.left:
				dfs(node.left)
			res.append(node.val)
			if node.right:
				dfa(node.right)
		res = []
		dfs(root)
		return res

class Solution:
	def inOrder(self,root:TreeNode):
		if not root:
			return []
		res = []
		stack = []
		cur = root
		while stack or cur:
			while cur:
				stack.append(cur)
				cur = cur.left
			node = cur.pop()
			res.append(node.val)
			cur = node.right
		return res

给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）中，按结点数值大小顺序第三小结点的值为4。
class Solution:
    # 返回对应节点TreeNode
    def KthNode(self, pRoot, k):
        # write code here
        def inorder(node):
            if not node:
                return []
            if node.left:
                inorder(node.left)
            res.append(node)
            if node.right:
                inorder(node.right)
        if not pRoot or k <= 0:
            return None
        res = []
        inorder(pRoot)
        if k > len(res):
            return None
        return res[k-1]


二分法：
搜索一个元素时，搜索区间两端闭
while条件带等号，否则需要打补丁
if相等就返回，其他的事甭操心
nid必须加减1，因为区间两端闭
while结束就凉了，凄凄惨惨返-1

搜索左右边界时，搜索区间要阐明
左闭右开最常见，其余逻辑便自明
while要小于号，这样才能不漏掉
if相等别返回，利用mid锁边界
mid加一或减一？要看区间开或闭
while结束不算完，因为你还没返回
索引可能出边界，if检查保平安


1、在排序数组中查找元素的第一个和最后一个位置,给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
你的算法时间复杂度必须是 O(log n) 级别。如果数组中不存在目标值，返回 [-1, -1]。
示例 1:
输入: nums = [5,7,7,8,8,10], target = 8
输出: [3,4]
示例 2:
输入: nums = [5,7,7,8,8,10], target = 6
输出: [-1,-1]


class Soluiton{
	pubLic int extremeInsesrtionIndex(int[] nums, int target){
		int[] res = new int[2];
		int left = 0;
		int right = nums.length;
		res[0] = searchLeft(nums,left,right,target);
		res[1] = searchRight(nums,left,right,target);
		return res;
	}

	private int searchLeft(int[] nums,int left,int right,int target){
		while(left < right){
			int mid = (left + right) >> 1;
			if(nums[mid] < target){
				left = mid+1;
			}else if(nums[mid] > target){
				right = mid;
			}else if(nums[mid] == target){
				right = mid;
			}
		}
		if(left == nums.length || nums[left] != target){
			return -1;
		}
		
		return left;
	}

	private int searchRight(int[] nums,int left,int right,int target){
		while(left < right){
			int mid = (left + right) >> 1;
			if(nums[mid] < target){
				left = mid+1;
			}else if(nums[mid] > target){
				right = mid;
			}else if(nums[num] == target){
				left = mid+1;
			}
		}
		if(right == 0 || nums[right - 1] != target){
			return -1;
		}
		return left-1;
	}
}

2、请实现有重复数字的有序数组的二分查找。输出在数组中第一个大于等于查找值的位置，如果数组中不存在这样的数，则输出数组长度加一。
示例1
输入
5,4,[1,2,4,4,5]
输出
3
class solution{
	public int upper_bound(int n,int v,int[] arr){
		int left =0;
		int right = n-1;
		while(left <= right){
			int mid = (left+right) >> 1;
			if(arr[mid] < v){
				left = mid+1;
			}else{
				if(mid == 0 || arr[mid-1] < v){
					return mid+1;
				}else{
					right = mid-1;
				}
			}
		}
		return n+1;
	}
}


# 2、面试题 10.03. 搜索旋转数组，搜索旋转数组。给定一个排序后的数组，包含n个整数，但这个数组已被旋转过很多次了，次数不详。请编写代码找出数组中的某个元素，假设数组元素原先是按升序排列的。若有多个相同元素，返回索引值最小的一个。
示例1:
 输入: arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 5
 输出: 8（元素5在该数组中的索引）
class Solution{
	public int search(int[] arr,int target){
		int left = 0;
    	int right = arr.length - 1;
    	while (left <= right) {
        	int mid = left + (right - left) / 2;
        	if (arr[left] < arr[mid]) { 
            	if (arr[left] <= target && target <= arr[mid]) {//左边序列有序
                	right = mid;
            	} else {
                	left = mid + 1;
            	}
        	} else if (arr[left] > arr[mid]) {
            	if ((arr[mid] < target) && (target <= arr[right]) && (arr[left] > arr[right])) { //右边序列有序
                	left = mid + 1;
            	} else {
                	right = mid;
            	}
       	 	} else if (arr[left] == arr[mid]) {  // 存在重复的元素
            	if (arr[left] != target) {
                	left++;
            	} else {
                	return left;       
            	}
       	 	}
    	}
    	return -1;
 	}
}

3、搜索旋转排序数组，假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。
搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。你可以假设数组中不存在重复的元素。
你的算法时间复杂度必须是 O(log n) 级别。
示例 1:
输入: nums = [4,5,6,7,0,1,2], target = 0
输出: 4
class Solution{
	public int search(int[] arr,int target){
		int left = 0;
    	int right = arr.length - 1;
    	while (left <= right) {
        	int mid = left + (right - left) / 2;
        	if (arr[left] < arr[mid]) { 
            	if (arr[left] <= target && target <= arr[mid]) {//左边序列有序
                	right = mid;
            	} else {
                	left = mid + 1;
            	}
        	} else if (arr[left] > arr[mid]) {
            	if ((arr[mid] < target) && (target <= arr[right]) && (arr[left] > arr[right])) { //右边序列有序
                	left = mid + 1;
            	} else {
                	right = mid;
            	}
       	 	} else if (arr[left] == arr[mid]) {  // 存在重复的元素
            	if (arr[left] != target) {
                	left++;
            	} else {
                	return left;       
            	}
       	 	}
    	}
    	return -1;
 	}
}

# 3、寻找重复数，给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。
示例 1:
输入: [1,3,4,2,2]
输出: 2
class Solution{
	public int findDuplicate(int[] nums){
		
		int left = 0;
		int right = nums.length-1;
		while(left < right){
			int mid = (left + right) >> 1;
			int cnt = 0;
			for(int num : nums){
				if(num <= mid){
					cnt ++;
				}
			}
			if(cnt > mid){
				right = mid;
			}else{
				left = mid+1;
			}
	}
	return left;
}

4、实现函数 int sqrt(int x).计算并返回x的平方根
示例1
输入
2
输出
1
/*
k^2 < x
二分法
*/ 
class solution{
	public int sqrt(int x){
		int left = 0;
		int right = x;
		int res = -1;
		while(left < right){
			int mid = (left + right) >> 1;
			if((long)mid * mid <= x){
				res = mid;
				left = mid + 1;
			}else{
				right = mid - 1;
			}
		}
		return res;
	}
}


数组相关

1、大小为 K 且平均值大于等于阈值的子数组数目：给你一个整数数组 arr 和两个整数 k 和 threshold 。请你返回长度为 k 且平均值大于等于 threshold 的子数组数目。
输入：arr = [2,2,2,2,5,5,5,8], k = 3, threshold = 4
输出：3
解释：子数组 [2,5,5],[5,5,5] 和 [5,5,8] 的平均值分别为 4，5 和 6 。其他长度为 3 的子数组的平均值都小于 4 （threshold 的值)。
class Solution{
	public int numOfSubarrays(int[] arr, int k, int threshold) {
		//滑动窗口
		int len = arr.length;
		int i = 0；
		int j = i+k-1;
		int count = 0;
		while(i < len && j < len){
			int sum = 0;
			for(int m = i;m<=j;m++){
				sum += arr[m];
			}
			if(sum / k >= thershold){
				count++;
			}
			i++;
			j++;
		} 
		return count;
    }
}
2、高度检查器：学校在拍年度纪念照时，一般要求学生按照 非递减 的高度顺序排列。请你返回能让所有学生以 非递减 高度排列的最小必要移动人数。 注意，当一组学生被选中时，他们之间可以以任何可能的方式重新排序，而未被选中的学生应该保持不动。
输入：heights = [1,1,4,2,1,3]
输出：3 
解释：
当前数组：[1,1,4,2,1,3]
目标数组：[1,1,1,2,3,4]
在下标 2 处（从 0 开始计数）出现 4 vs 1 ，所以我们必须移动这名学生。
在下标 4 处（从 0 开始计数）出现 1 vs 3 ，所以我们必须移动这名学生。
在下标 5 处（从 0 开始计数）出现 3 vs 4 ，所以我们必须移动这名学生。
class Solution{
	public int heightChecker(int[] arr){
		if(arr == null || arr.length == 0){
			return 0;
		}
		int[] tmp = arr.clone();
		int count = 0;
		Arrays.sort(arr);
		for(int i = 0;i < ar..length;i++){
			if(tmp[i] != arr[i]){
				count++;
			}
		}
		return count;
	}
}

4、349. 两个数组的交集，给定两个数组，编写一个函数来计算它们的交集。
示例 1：
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
示例 2：
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
class Solution{
	public int[] intersection(int[] nums1, int[] nums2){
		if(nums1 == null || nums2 == null){
			return new int[0];
		}
		Set<Integer> set = new HashSet<>();
		Set<Integer> set = new HashSet<>();

		for(int item : nums1){
			set.add(item);
		}

		for(int item : nums2){
			if(set1.contains(item)){
				set2.add(item);
			}
		}

		int[] res = new int[set2.size()];
		int i = 0;
		for(int item : set2){
			res[i++] = item;
		}
		return res;
	}
	
}

5、最长连续序列，给定一个未排序的整数数组，找出最长连续序列的长度。要求算法的时间复杂度为 O(n)。
示例:
输入: [100, 4, 200, 1, 3, 2]
输出: 4
解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。
class solution{
	public int longestConsecutive(int[] nums){
		int longest = 0;
		Set<Integer> set = new HashSet<>();
		for(int num : nums){
			set.add(num);
		}
		for(int num : set){
			if(!set.contains(num-1)){
				int curNum = num;
				int curLen = 1;

				while(set.contains(curNum + 1)){
					curNum++;
					curLen++;
				}
				longest = Math.max(longest,curLen);
			}

		}
		return longest;
	}
}

6、最长连续递增序列，给定一个未经排序的整数数组，找到最长且连续的的递增序列，并返回该序列的长度。
输入: [1,3,5,4,7]
输出: 3
解释: 最长连续递增序列是 [1,3,5], 长度为3。
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。 
class Solution{
	public int findLengthOfLCIS(int[] nums){
		if(nums.length <= 1){
			return nums.length;
		}
		int res = 1;
		int count = 1;
		for(int i = 1;i < nums.length;i++){
			if(nums[i] > nums[i-1]){
				count++;
				
			}else{
				count = 1;
			}
			res = Math.max(count, res);
		}

		return res;

	}
}


6、旋转数组，给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。
示例 1:
输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
//交换3次
class Solution{
	public void rotatr(int[] nums,int k){
		int n = nums.length;

		k %= n;
		reverse(nums,0,n-1);
		reverse(nums,0,k-1);
		reverse(nums,k,n-1);
	

	public void reverse(int[] nums, int left, int right){
		while(left < right){
			int tmp = nums[left];
			nums[left] = nums[right];
			nums[right] = tmp;
			left++;
			right--;
		}
	}
}

7、三数之和，给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。
注意：答案中不可以包含重复的三元组。
示例：
给定数组 nums = [-1, 0, 1, 2, -1, -4]，
满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]

class Solution {
    public static List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> ans = new ArrayList();
        int len = nums.length;
        if(nums == null || len < 3) return ans;
        Arrays.sort(nums); // 排序
        for (int i = 0; i < len ; i++) {
            if(nums[i] > 0) break; // 如果当前数字大于0，则三数之和一定大于0，所以结束循环
            if(i > 0 && nums[i] == nums[i-1]) continue; // 去重
            int L = i+1;
            int R = len-1;
            while(L < R){
                int sum = nums[i] + nums[L] + nums[R];
                if(sum == 0){
                    ans.add(Arrays.asList(nums[i],nums[L],nums[R]));
                    while (L<R && nums[L] == nums[L+1]) L++; // 去重
                    while (L<R && nums[R] == nums[R-1]) R--; // 去重
                    L++;
                    R--;
                }
                else if (sum < 0) L++;
                else if (sum > 0) R--;
            }
        }        
        return ans;
    }
}

# 最接近的三数之和，给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。
示例：
输入：nums = [-1,2,1,-4], target = 1
输出：2
解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。
class solution{
	public int threeSumClosest(int[] nums,int target){
		if(nums == null || nums.length == 0){
			return target;
		}
		Arrays.sort(nums);
		int res = nums[0] + nums[1] + nums[2];
		//定义基数
		for(int i = 0;i < nums.length-2;i++){
			//定义两个指针
			int left = i+1;
			int right = nums.length - 1;

			while(left < right){
				int sum = nums[i] + nums[left] + nums[right];
				if(Math.abs(target - sum) < Math.abs(target - res)){
					res = sum;
				}
				if(sum < target){
					left++;
				}else if(sum > target){
					right--;
				}else{
					return res;
				}
			}
		}
		return res;
	}
}

# 电话号码的字母组合,给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
输入："23"
输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
class Solution {
    public List<String> letterCombinations(String digits) {
        List<String> combinations = new ArrayList<String>();
        if (digits.length() == 0) {
            return combinations;
        }
        Map<Character, String> phoneMap = new HashMap<Character, String>() {{
            put('2', "abc");
            put('3', "def");
            put('4', "ghi");
            put('5', "jkl");
            put('6', "mno");
            put('7', "pqrs");
            put('8', "tuv");
            put('9', "wxyz");
        }};
        backtrack(combinations, phoneMap, digits, 0, new StringBuffer());
        return combinations;
    }

    public void backtrack(List<String> combinations, Map<Character, String> phoneMap, String digits, int index, StringBuffer combination) {
        if (index == digits.length()) {
            combinations.add(combination.toString());
        } else {
            char digit = digits.charAt(index);
            String letters = phoneMap.get(digit);
            int lettersCount = letters.length();
            for (int i = 0; i < lettersCount; i++) {
                combination.append(letters.charAt(i));
                backtrack(combinations, phoneMap, digits, index + 1, combination);
                combination.deleteCharAt(index);
            }
        }
    }
}

# 四数之和,给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。
注意：
答案中不可以包含重复的四元组。
示例：
给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。
满足要求的四元组集合为：
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> res = new LinkedList<>();
		List<Integer> list = new LinkedList<>();
		Arrays.sort(nums);
		//第一个基准值从前面开始
		for(int base1 = 0;base1<nums.length-3;base1++) {
			//第二个基准值从后面开始
			for(int base2 = nums.length-1;base2>base1+2;base2--) {
				if(base2 < nums.length-1 && nums[base2] == nums[base2+1]) {
					continue;
				}else if(base1 > 0 && nums[base1] == nums[base1-1]) {
					continue;
				}
				int left = base1+1;
				int right = base2-1;
				int sum = target - nums[base1]-nums[base2];
				while(left<right) {
					if(sum == nums[left] + nums[right]) {
						res.add(Arrays.asList(nums[base1],nums[base2],nums[left],nums[right]));
						//去重
						while(left<nums.length-1 && nums[left] == nums[left+1]) {
							left++;
						}
						while(right>0 && nums[right] == nums[right-1]) {
							right--;
						}
						left++;
						right--;
						
					}else if(sum < nums[left] + nums[right]) {
						right--;
					}else {
						left++;
					}
				}
			}
		}
		return res;
    }
}

# 移除元素，给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
示例 1:
给定 nums = [3,2,2,3], val = 3,
函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。
你不需要考虑数组中超出新长度后面的元素。
class Solution{
	public int removeElement(int[] nums, int val){
		if(nums == null || nums.length == 0){
			return 0;
		}
		int count = 0;
		for(int j = 0;j < nums.length;j++){
			if(nums[j] != val){
				nums[count] = nums[j];
				count++;
			}
		}
		return count;
	}
}

# 实现 strStr(),实现 strStr() 函数。给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。
示例 1:
输入: haystack = "hello", needle = "ll"
输出: 2
示例 2:
输入: haystack = "aaaaa", needle = "bba"
输出: -1
class Solution{
	public int strStr(String s1,String s2){
		int len1 = s1.length();
		int len2 = s2.length();
		for(int start = 0;start < len1-len2+1;start++){
			if(s1.substring(start,start+len2).equals(needle)){
				return start;
			}
		}
		return -1;
	}
}
合并两个有序数组：
给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。
输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]
class solution{
	public void merge(int[] nums1,int m,int[] nums2,int n){
		int len1 = m-1;
		int len2 = n-1;
		int len = m+n-1;

		while(len1 >= 0 && len2 >= 0){
			if(nums1[len1] > nums2[len2]){
				nums1[len--] = nums1[len1--];
			}else{
				nums1[len--] = nums2[len2--];
			}
		}
		while(len2 >= 0){
			nums1[len--] = nums2[len2--];
		}
	}
}


8、盛最多水的容器
输入：[1,8,6,2,5,4,8,3,7]
输出：49
class Solution{
	public int maxArea(int[] height){
		int i = 0;
		int j = height.length - 1;
		int max = 0;
		while(i < j){
			int short = height[i] < height[j] ? height[i] : height[j];
			max = max > (j-i)* short ? max : (j-i)* short;
			if(height[i] > height[j]){
				j--;
			}else{
				i++;
			}
		}
		return max;
	}
}


9、合并区间，给出一个区间的集合，请合并所有重叠的区间。
示例 1:
输入: intervals = [[1,3],[2,6],[8,10],[15,18]]
输出: [[1,6],[8,10],[15,18]]
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
示例 2:
输入: intervals = [[1,4],[4,5]]
输出: [[1,5]]
解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。
class Solution{
	public int[][] merge(int[][] intervals){
		if(intervals.length == 0){
			return intevals;
		}
		//按第一个元素合并
		Arrays.sort(intevals,new Comparator<int[]>(){
			public int compare(int[] a,int[] b){
				return a[0] - b[0];
			}
		});

		List<int[]> res = new ArrayList<>();
		//第一个线段
		int[] cur = intervals[0];
		for(int i = 1;i < intervals.length; i++){
			//下一个位置的开始位置大于前一个的结束位置
			if(intervals[i][0] > cur[1]){
				//就说明没有重叠就添加到结果集中
				res.add(cur);
				cur = intervals[i];
			}else{
				//有重叠的话找这两个的最大终点
				cur[1] = Math.max(cur[1],intervals[i][1]);
			}
		}
		res.add(cur);
		int[][] ans = new int[res.size()][2];
		for(int i = 0;i<res.size();i++){
			ans[i] = res.get(i);
		}
		return ans;


	}
}


字符串：

1、反转字符串：
输入：["h","e","l","l","o"]
输出：["o","l","l","e","h"]
//双指针法
class Solution{
	public void reverseString(char[] s){
		int left = 0;
		int right = s.length - 1;
		while(left <= right){
			char tmp = s[left];
			s[left] = s[right];
			s[right] = tmp;
			left++;
			right--;
		}
	}
}

2、反转字符串2：给定一个字符串 s 和一个整数 k，你需要对从字符串开头算起的每隔 2k 个字符的前 k 个字符进行反转。
如果剩余字符少于 k 个，则将剩余字符全部反转。
如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。
示例:
输入: s = "abcdefg", k = 2
输出: "bacdfeg"
//双指针
class solution{
	public Stirng reverseStr(String s, int k){
		char[] chars = s.toCharArray();
		int n = chars.length;
		//每2k元素为一组进行反转
		for(int i = 0;i < n;i += 2*k){
			int left = i;
			//判断下标是否越界
			int right = i + k -1 ? i+k-1:n-1;
			//双指针交换
			while(left < right){
				char tmp = chars[left];
				chars[left] = chars[right];
				chars[right] = tmp;
			}
		}
		return String.valueOf(chars);
	}
}

3、反转字符串中的单词 III
给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序
输入："Let's take LeetCode contest"
输出："s'teL ekat edoCteeL tsetnoc"
class Solution{
	String[] ss = s.split(" ");
	StringBuffer sb = new StringBuffer();
	for(String c : ss){
		for(int i = c.length() - 1;i >= 0;i--){	
			sb.append(c.charAt(i));
		}
		sb.append(" ");
	}
	return sb.toString().trim();
}

4、翻转字符串里的单词，给定一个字符串，逐个翻转字符串中的每个单词。
示例 1：
输入: "the sky is blue"
输出: "blue is sky the"
class Solution{
	public String reverseWords(String s){
		if(s == null || s.length == 0){
			return ""；
		}
		s = s.trim();
		String[] c = s.split(" ");
		StringBuffer sb = new StringBuffer();

		for(int i = c.length - 1;i >= 0;i--){
			if(c[i].equals("")){
				continue;
			}
			sb.append(c[i] + " ");
		}
		return sb.toString().trim();
	}
}

4、比较版本号，比较两个版本号 version1 和 version2。，如果 version1 > version2 返回 1，如果 version1 < version2 返回 -1， 除此之外返回 0。
你可以假设版本字符串非空，并且只包含数字和 . 字符。. 字符不代表小数点，而是用于分隔数字序列。
例如，2.5 不是“两个半”，也不是“差一半到三”，而是第二版中的第五个小版本。
你可以假设版本号的每一级的默认修订版号为 0。例如，版本号 3.4 的第一级（大版本）和第二级（小版本）修订号分别为 3 和 4。其第三级和第四级修订号均为 0。
示例 1:
输入: version1 = "0.1", version2 = "1.1"
输出: -1
示例 2:
输入: version1 = "1.0.1", version2 = "1"
输出: 1
class Solution{
	pulic int compareVersion(String version1,String version2){
		String[] s1 = version1.split("\\.");  //注意\\
		String[] s2 = version2.split("\\.");
		int len1 = s1.length;
		int len2 = s2.length;

		int len = Math.max(len1,len2);

		for(int i = 0;i < len;i++){
			int num1 = i < len1 ? Integer.parseInt(s1[i]) : 0;
			int num2 = j < len2 ? Integer.parseInt(s2[i]) : 0;
			if(num1 > num2){
				return 1;
			}else if(num1 < num2){
				return -1;
			}
		}
		return 0; 
	}
}

5、最长回文子串： 最长回文子串，给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。
示例 1：
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
/*
动态规划
如果一个字符串的头尾两个字符都不相等，那么这个字符串一定不是回文串；
如果一个字符串的头尾两个字符相等，才有必要继续判断下去。
如果里面的子串是回文，整体就是回文串；
如果里面的子串不是回文串，整体就不是回文串。
*/
class solution{
	public String longestPalindrome(String s){
		String res = "";
		boolean[][] dp = new boolean[s.length()][s.length()];

		//length == 1，  一个元素时全是true,自己肯定等于自己呀
		for(int i = 0;i < dp.length;i++){
			dp[i][i] = true;
			res = s.substring(i,i+1); //左闭右开
		}

		//length == 2,两个元素相等时为tru，否则为false
		for(int i = 0;i < dp.length-1;i++){
			if(s.charAt(i) == s.charAt(i+1)){
				dp[i][i+1] = true;
				res = s.substring(i,i+2);
			}else{
				dp[i][i+1] = false;
			}
		}
		//length > 2
		for(int i = 3;i <= dp.length;i++){
			for(int j = 0;j+i <= dp.length;j++){
				char front = s.charAt(j);
				char end = s.charAt(j+i-1);
				if(front == end){
					dp[j][j+i-1] = dp[j+1][j+i-2];
				}else{
					dp[j][j+i-1] = false;
				}

				if(dp[j][j+i-1]){
					res = s.substring(j,j+i);
				}
			}
		}
		return res;
	}
}


6、 重复的子字符串，给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。
示例 1:
输入: "abab"
输出: True
解释: 可由子字符串 "ab" 重复两次构成。
示例 2:
输入: "aba"
输出: False
/*
如果我们移除字符串 ss 的前 n'n 
  个字符（即一个完整的 s's 
 ），再将这些字符保持顺序添加到剩余字符串的末尾，那么得到的字符串仍然是 ss。由于 1 \leq n' < n1≤n 
 <n，那么如果将两个 ss 连在一起，并移除第一个和最后一个字符，那么得到的字符串一定包含 ss，即 ss 是它的一个子串。
*/
class Solution{
	public boolean repeatedSubstringPattern(String s){
		return (s+s).substring(1,2 * s.length() -1).indexOf(s) != -1;

	}
}

7、有效的括号，给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。
有效字符串需满足：
左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
注意空字符串可被认为是有效字符串。
示例 1:
输入: "()"
输出: true
示例 2:
输入: "()[]{}"
输出: true
class solution{
	public boolean isValid(String s){
		Stack<Character> stack = new Stack<>();
		char[] c = s.toCharArray();
		for(char cc : c){
			if(stack.isEmpty()){
				stack.push(cc);
			}

			if(isMatch(stack.peek(),cc)){
				stack.pop();
			}else{
				stack.push(cc);
			}
			
		}
		return stack.isEmpty();
	}

	public boolean isMathch(char a, char b){
		if((a == '(' && b == ')')  || (a == '[' && b == ']') || (a == '{' && b == '}')) {
			return true;
		}else{
			return false;
		}
	}

}

8、最长有效括号，给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。
示例 1:
输入: "(()"
输出: 2
解释: 最长有效括号子串为 "()"
示例 2:
输入: ")()())"
输出: 4
解释: 最长有效括号子串为 "()()"
class Solution{
	public int longestValidParenthese(String s){
		Stack<Integer> stack = new Stack<>();
		stack.push(-1);
		int max = 0;
		for(int i = 0;i < s.length();i++){
			if(s.cahrAt(i) == '('){
				stack.push(i);
			}else{
				stack.pop();
				if(stack.isEmpty()){
					stack.push(i);
				}else{
					max = Math.max(max,i-stack.peek());
				}
			}
		}
		return max;
	}
}


9、最小覆盖子串，给你一个字符串 S、一个字符串 T 。请你设计一种算法，可以在 O(n) 的时间复杂度内，从字符串 S 里面找出：包含 T 所有字符的最小子串。
示例：
输入：S = "ADOBECODEBANC", T = "ABC"
输出："BANC"
class Solution{
	public String minWindow(String s, String t){
		//定义一个初始量一会标记满足条件窗口的左指针
		int start = 0;
		//滑动窗口的左右指针
		int left = 0;
		int right = 0;
		int minLen = Integer.MAX_VALUE;
		//记录需要的元素
		Map<Character,Integer> needs = new HashMap<>();
		//记录滑动窗口里的值
		Map<CHaracter,Integer> window = new HashMap<>();

		//遍历t字符串
		for(char ch : t.toCharArray()){
			needs.put(ch, needs.getOrDefault(ch,0) + 1);
		}

		//当前subString和t中匹配的数量
		int match = 0;
		//右指针不出界
		while(right < s.length()){
			char c1 = s.charAt(right);
			//如果右指针所指的元素是needs里需要的
			if(needs.containsKey(c1)){
				//滑动窗口里添加上
				window.put(c1,window.getOrDefault(c1, 0) + 1);
				//如果某一元素的滑动窗口的个数和needs中的个数相同
				if(window.get(c1).compareTo(needs.get(c1)) == 0){
					//匹配的个数+1
					match++;
				}
			}
			right++;
			//当所有元素匹配完了，就得移动左指针缩小窗口
			while(match == needs.size()){
				if(right - left < minLen){
					start = left;
					minLen = right -left;
				}
				char c2 = s.charAt(left);
				if(needs.containsKey(c2)){
					window.put(c2,window.get(c2) - 1);
					if(window.get(c2) < needs.get(c2)){
						match--;
					}
					
				}
				left++;
			}
		}
		return minLen == Integer.MAX_VALUE ? "":s.substring(start,start+minLen);
	}
}

10、字符串相乘,给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。
示例 1:
输入: num1 = "2", num2 = "3"
输出: "6"
示例 2:
输入: num1 = "123", num2 = "456"
输出: "56088"
		1  2  3
		4  5  6
	   ----------
	    6 12 18
	 5 10 15
   4 8 12
 存在一个数组中再取余，进位
class Solution{
	public String multiply(String num1,String num2){
		if(num1.equals("0") || nums2.equals("0")){
			return "0";
		}
		int m = num1.length();
		int n = num2.length();
		int[] ansArr = new int[m+n];
		for(int i = m-1;i >= 0;i--){
			int x = num1.charAt(i) - '0';
			for(int j = n-1; j >= 0;j--){
				int y = num2.charAt(j) -'0';
				ansArr[i+j+1] += x * y;
			}
		}
		for(int i = m+n-1;i > 0;i--){
			//加上前一个的进位
			ansArr[i-1] += ansArr[i] / 10;
			ansArr[i] %= 10;
		}
		int index = ansArr[0] == 0?1:0;
		StringBuffer sb = new StringBuffer();
		while(index < m+n){
			ans.append(ansArr[index]);
			index++;
		}
		return ans.toString();
	}
}

全排列：

1、给定一个没有重复数字的序列，返回其所有可能的全排列
输入[1,2,3]
输出[[1,2,3],
	[1,3,2],
	...
	]
class Solution:
	def permute(self, nums: List[int]) -> List[List[int]]:
		def dfs(nums,tmp):
			if not nums:
				res.append(tmp[:])
			ss = set()
			for i in range(len(nums)):
				if nums[i] in ss:
					continue
				ss.add(nums[i])
				dfs(nums[:i] + nums[i+1:], tmp + [nums[i]])
		res = []
		dfs(nums,[])
		return res

2、给定一个可包含重复数字的序列，返回所有不重复的全排列。
示例:
输入: [1,1,2]
输出:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
class solution:
	def permuteUnique(self,nums):
		def dfs(nums,tmp):
			if not nums:
				res.append(tmp[:])
			s = set()
			for i in range(len(nums)):
				if nums[i] in s:
					continue
				dfs(nums[:i]+nums[i+1:] , tmp + [nums[i]])
				s.add(nums[i])
		res = []
		dfs(nums,[])
		return res

3、剑指 Offer 38. 字符串的排列,输入一个字符串，打印出该字符串中字符的所有排列。你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。
	示例:

	输入：s = "abc"
	输出：["abc","acb","bac","bca","cab","cba"]
	class Solution:
    	def permutation(self, s: str) -> List[str]:
    		self.res = []
    		n = len(s)

    		def dfs(s,path):
    			# 终止条件
    			if not s:
    				self.res.append(path)
    			ss = set()
    			for i in range(len(s)):
    				# 去重
    				if s[i] in ss:
    					continue
    				ss.add(s[i])
    				dfs(s[:i]+s[i+1:],path+s[i])

    		dfs(s,"")
    		return self.res
4、字符串的排列： 字符串的排列，给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。
换句话说，第一个字符串的排列之一是第二个字符串的子串。
示例1:
输入: s1 = "ab" s2 = "eidbaooo"
输出: True
解释: s2 包含 s1 的排列之一 ("ba").
示例2:
输入: s1= "ab" s2 = "eidboaoo"
输出: False
/*

如上所述，只有当两个字符串包含具有相同频率的相同字符时，一个字符串才是另一个字符串的排列。我们可以考虑与 s1s1 长度相同的长字符串 s2s2 中的每个可能的子字符串，并检查出现在两者中的字符出现的频率。如果每个字母的频率完全匹配，则只有 s1s1 的排列可以是 s2s2 的子字符串。

为了实现这种方法，我们不使用排序然后比较元素的相等性，而是使用一个哈希表 s1maps1map来存储短字符串 s1s1 中所有字符的出现频率。我们考虑 s2s2 的每个可能的子串，其长度与 s1s1 的长度相同，也可以找到相应的哈希表，即 s2maps2map。因此，所考虑的子字符串可以被视为一个长度窗口，如 s1s1 迭代超过 s2s2。如果获得的两个哈希表对于任何这样的窗口是相同的，我们可以得出结论 s1s1 的排列是 s2s2 的子字符串，否则不是。
*/
class Solution{
	public boolean checkInclusion(String s1,String s2){
		int len1 = s1.length();
		int len2  = s2.length();
		s1.sort();
		for(int i = 0;i < len2-len1;i++){
			if(s1.equals(sort(s2.substring(i,i+len1)))){
				return true;
			}
		}
		return false;
	}

	public String sort(String s){
		char[] c = s.toCharArray();
		Arrays.sort(c);
		return new String(c);
	}
}


5、子集，给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。
说明：解集不能包含重复的子集。
示例:
输入: nums = [1,2,3]
输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
#回溯
class solution:
	def subsets(self,nums):
		def dfs(first = 0, tmp = []):
			if len(tmp) == k:
				res.append(tmp[:])
			for i in range(first, n):
				tmp.append(nums[i])
				dfs(i+1, tmp)
				tmp.pop()
		res = []
		n = len(nums)
		for k in range(n+1):
			dfs()
		return res

6、括号生成，数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。
示例：
输入：n = 3
输出：[
       "((()))",
       "(()())",
       "(())()",
       "()(())",
       "()()()"
     ]
def Solution:
	def generateParenthesis(self,n):
		res = []
		dfs(n,n,res,"")
		return res
	def dfs(self,n1,n2,res,tmp):
		if n1 > n2:
			return 
		if n1 == 0 and n2 == 0:
			res.append(tmp)
		if n1 > 0:
			self.dfs(n1-1,n2,res,tmp+"(")
		if n2 > 0:
			self.dfs(n1,n2-1,res,tmp+")")

9、组合总和 II，给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的每个数字在每个组合中只能使用一次。
说明：
所有数字（包括目标数）都是正整数。
解集不能包含重复的组合。 
示例 1:
输入: candidates = [10,1,2,7,6,1,5], target = 8,
所求解集为:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
//回溯加减枝
class Solution:
	def combinaSum2(self, candidates:List[int],target:int):
		res = []
		candidates.sort()
		def backtrack(candidates,tmp):
			if sum(tmp) > target:
				return
			if sum(tmp) == target:
				res.append(tmp)
				return
			for i in range(len(candidates)):
				if i > 0 and candidates[i] == candidates[i-1]:
					continue
				backtrack(candidates[i+1:], tmp+ [candidates[i]])
			return res
		return backtrack(candidates, [])

每日一题：

# 给定两个字符串，输出A,B字符串中都出现过的单词占各自文本中的比例
if __name__=='__main__':
	a = set(input().strip()[:2].split())
	b = set(input().strip()[:2].split())
	tmp = list(a) + list(b)
	count = len(tmp) - len(set(tmp))
	print('A:' + str(100*count/len(a)) + '%')
	print('B:' + str(100*count/len(b)) + '%')

# 给定一个 0-4随机数生成器 如何生成0-6随机数，并且出现的概率相等
rand7()比rand5()多了两个数5,6，也就是说如何利用已有的0,1,2,3,4来构造出5,6,一个简单的想法是: 1.5*rand5(),但会漏掉1，4.不行
书上解法：从rand7()真正生成的角度来看，应该是： 整数 % 7需要确保返回0~6的概率都为1/7,产生一个范围的数值，每个数值出现的概率相同(范围内至少有7个元素)，舍弃后面大于7的倍数的部分，将剩下元素除以7取余数即可
用 5 * rand5() + rand5()构造出了:0~24，且每个被取得的概率相同，之所以是 5 * rand5(),是因为0~4中缺少5，所以这个5刚好可以用1 * 5取得，因此，这里是乘以5


class Main{
    public static void main(String[] args) {
        int[] result = new int[7];
        for (int i = 0; i < 50000; i++) {
            int r = rand6();
            result[r]++;
        }
        for (int i = 0; i < result.length; i++) {
            System.out.println("num:" + i + " times: " + result[i]);
        }
    }

    public static int rand4() {
        //random函数生成大于等于 0.0 且小于 1.0
        double rand = Math.random() * 5;
        return (int) rand;
    }

    // 0 -6 实际 7个数字
    public static int rand6() {
        int result = rand4() * 5 + rand4();
        if(result < 21){
        	return result % 7;
        }
    }
}
# 给定一个字符串，包含字母、数字以及空格，找出字符串中"Good"的个数
import java.util.*;

public class Main3 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String s = scanner.nextLine().trim();

        int len = s.length();
        Map<Character,Integer> map = new HashMap<>();

        Queue<Integer> queueG = new LinkedList<>();
        Queue<Integer> queueO = new LinkedList<>();
        Queue<Integer> queueD = new LinkedList<>();
        for (int i = 0; i < len; i++) {
            if(s.charAt(i) == 'G'){
                queueG.offer(i);
            }else if(s.charAt(i) == 'o'){
                queueO.offer(i);
            }else if(s.charAt(i) == 'd'){
                queueD.offer(i);
            }
        }

        if(queueG.size()< 1 || queueO.size() < 2 || queueD.size() < 1 ){
            System.out.println(0);
        }else{
            int res = 0;
            boolean flag = true;
            while (queueG.size()>=1 && queueO.size() >=2 && queueD.size() >= 1){
                int indexG = queueG.poll();//最早的G
                int indexO = 0;
                while (!queueO.isEmpty() && queueO.peek() < indexG){//能用的最早的O
                    queueO.poll();
                }
                if(queueO.size()<2){
                    flag = false;
                    break;
                }else{
                    queueO.poll();
                    indexO = queueO.poll();
                }

                while (!queueD.isEmpty() && queueD.peek() < indexO){//能用的最早的D
                    queueD.poll();
                }
                if(queueD.size() < 1){
                    flag = false;
                    break;
                }else{
                    queueD.poll();
                    res++;
                }
            }
            System.out.println(res);
        }

    }
}
#给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一，回文串是指正反两个方向都一样的单词或短语，排列是指字母的重新排列
"tactcoa"
true ("tacocat" "atcocta")

class solution{
	public boolean isPair(String s){
		if(s == null){
			return false;
		}
		char[] c = s.toCharArray();
		Set<Character> set = new HashSet<>();
		for(char cc : c){
			if(set.contains(cc)){
				set.remove(cc);
			}else{
				set.add(cc);
			}
		}
		return set.size() <= 1 ;
	}
}

class Solution{
	public boolean canPermute(String s){
		Map<Character, Integer> map = new HashMap<>();
		char[] c = s.toCharArray();
		for(char cc : c){
			if(map.containsKey(cc)){
				map.put(cc,map.get(cc)+1);
			}else{
				map.put(cc,1);
			}
		}
		int count = 0;
		for(char cc : c){
			if(map.get(cc) == 1){
				count++;
			}
		}

		if(count > 1){
			return false;
		}else{
			return true;
		}
	}
}

# 给你数字 k ，请你返回和为 k 的斐波那契数字的最少数目，其中，每个斐波那契数字都可以被使用多次。斐波那契数字定义为：
F1 = 1
F2 = 1
Fn = Fn-1 + Fn-2 ， 其中 n > 2 。
数据保证对于给定的 k ，一定能找到可行解。
class Solution:
	def indMinFibonacciNumbers(self, k: int) -> int:
		a = b = 1
		fibo = [a,b]
		ans = 0
		while a+b <= k:
			fibo.append(a+b)
			a,b = b,a+b
		for num in fibo[::-1]:
			if num <= k:
				ans += 1
				k -= num
		return ans
# 最长公共子序列：给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。
一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。
若这两个字符串没有公共子序列，则返回 0。
输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace"，它的长度为 3。

class Solution{
	public int longestCommonSubsequence(String text1,String text2){
		//动态规划
		int len1 = text1.length();
		int len2 = text2.length();
		int[][] dp = new int[len1+1][len2+1];
		for(int i = 1;i < len1;i++){
			for(int j = 1;j < len2;j++){
				if(text1.charAt(i-1) == text2.charAt(j-1)){
					dp[i][j] = dp[i-1][j-1] + 1;
				}else{
					dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
				}
			}
		}
		return dp[len1][len2]

	}
}

#字符串解码：给定一个经过编码的字符串，返回它解码后的字符串。编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。
你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。
示例 1：
输入：s = "3[a]2[bc]"
输出："aaabcbc"
示例 2：
输入：s = "3[a2[c]]"
输出："accaccacc"
class solution{
	ppublic String decodeString(String s){
		//存放重复次数
		Stack<Integer> numStack = new Stack<>();
		//存放字母
		Stack<String> strStack = new Stack<>();
		//记录到当前为止的string
		StringBuilder tail = new StringBuilder();
		int n = s.length();
		for(int i = 0;i < n;i++){
			char  c = s.charAt(i);
			if(Character.isDigit(c)){
				int num = c - '0';
				while(i+1 < n && Character.isDigit(s.charAt(i+1))){
					num = num * 10 + s.charAt(i+1) - '0';
					i++;
				}
				numStack.push(num);
			}else if(c == '['){ //要终止已经记录的stringbuilder
				strStack.push(tail.toString());
				//清空
				tail = new StringBuilder(); 
			}else if(c == ']'){
				StringBuilder tmp = new StringBuilder(strStack.pop());
				int repeatedTimes  = numStack.pop();
				for(int j = 0;j < repeatedTimes;j++){
					tmp.append(tail);
				}
				tail = tmp;
			}else{ //字母
				tail.append(c);
			}
		}
		return tail.toString();

	}
}

# 压缩字符串,给定一组字符，使用原地算法将其压缩。压缩后的长度必须始终小于或等于原数组长度。数组的每个元素应该是长度为1 的字符（不是 int 整数类型）。在完成原地修改输入数组后，返回数组的新长度。
class solution{
	public int compress(char[] chars){
		int n = chars.length;
		int cur = 0; //我们当前操作字符的位置
		for(int i = 0;i < n;){
			int j = i;
			while(j < n-1 && chars[j] == chars[j+1]){
				j++;
			}
			chars[cur++] = chars[i];
			if(i != j){ //有重复的时候
				String times = (j-i+1) + "";
				int len = times.length();
				for(int k = 0;k < len;k++){
					chars[cur++] = times.charAt(k);
				}
			}
			i = j+1;
		}
		return cur;
	}
}

# 去除驼峰字符串：
public class solution {
	public static void main(String [] args){
		Scanner in = new Scanner(System.in);
		String s = in.next();
		char [] c = s.toCharArray();
		int len = c.length;
		if(len <= 2)
			System.out.println(c);
		int j = -1;
		for(int i = 0; i < len - 2;i++){
			if(c[i] == c[i+2] && c[i] != c[i+1]){
				j = i + 2;
				i++;
			}else if(i != j){
				System.out.print(c[i]);
			}
		}
		in.close();
	}

}

# 求数组中出现次数最多且最大的数
class Solution{
	public int getMaxNumber(int[] nums){
		Map<Integer,Integer> map = new HashMap<>();
		for(int num : nums){
			if(map.containsKey(num)){
				map.put(num, map.get(num) + 1)
			}else{
				map.put(num,1);
			}
			
		}
		int count = -1;
		int max = Integer.MIN_VALUE;
		Iterator<Entry<Integer,Integer>> iter = map.entrySet.iterator();
		while(iter.hashNext()){
			Map.Entry<Integer, Integer> entry = iter.next();
			if(entry.getValue() > count || (entry.getValue() == count && entry.getKey() > max)){
				max = entry.getKey();
				count = entry.getValue();
			}
		}
		return count;

	}
}





# 有两个很长很很长的字符串，但是字符都是数字，实现这俩字符串的加法，输出为一个字符串。如str1="1231213347845713824718237489123748343246217489132", str2="623478573127438912743892017489132748172341324132"，数值的加法，不是字符串合并。
class Solution{
	public String TwoStringAdd(String s1,String s2){
		int len1 = s1.length();
		int len2 = s2.length();
		int i = len1-1;
		int j = len2-1;
		StringBuffer sb = new StringBuffer();
		int flag = 0;
		while(i >= 0 || j >= 0 || flag != 0){
			int num1 = s1.charAt(i) == ""? 0 : Integer.parseInt(s1.charAt(i));
			int num2 = s2.charAt(j) == ""? 0 : Integer.parseInt(s2.charAt(j));

			int add = flag + num1 + num2;
			flag = add / 10;
			sb.append(add % 10);
			i--;
			j--;
		}

		return sb.reverse().toString();
	}
}

# 数字n代表生成括号的对数，请你设计一个函数，生成所有可能的有效括号的组合
class Solution:
	def method(self, n):
		res = []
		self.dfs(n,n,"",res)
		return res

	def dfs(self,left,right,tmp,res)
		if left == 0 and right == 0:
			res.append(tmp)
		if left > right:
			return
		if left > 0:
			self.dfs(left-1,right,tmp+"(",res)
		if right > 0:
			self.dfs(left,right-1,tmp+")",res)

# 给定一个数组，将负数放左边，正数放到数组的右边
class Solution{
	public void sort(int[] arr){
		if(arr == null || arr.length == 0){
			return;
		}
		int i = 0;
		int j = arr.length-1;

		while(i < j){
			if(arr[i] < 0 && arr[j] > 0){
				i++;
				j--;
			}
			if(arr[i] < 0 && arr[j] < 0){
				i++;
			}
			if(arr[i] > 0 && arr[j] > 0){
				j--;
			}
			if(arr[i] > 0 && arr[j] < 0){
				int tmp = arr[i];
				arr[i] = arr[j];
				arr[j] = tmp;
				i++;
				j--;
			}
		}
	}
# 从1到100000000中取出一个数，写代码找出取出的是哪个数。
class Solution{
	public static void main(String[] args) {
		int target = 256;
		int[] arr = new int[10000000000];
		int j = 0;
		for(int i = 1;i <= 10000000000;i++){
			arr[j++] = i;
		}
		int res = findNumber(arr,target);
		return res;
	}
	public static int findNumber(int[] arr,int target){
		int left = 0;
		int right = arr.length - 1;
		while(left <= right){
			int mid = (left + right) >> 1;
			if(arr[mid] == target){
				return arr[mid];
			}else if(arr[mid] > target){
				right = mid-1;
			}else{
				left = mid+1;
			}
		}
		return 0;
	}
}

# 输入一个字符串，统计字符串中各个字符出现的次数，并按出现频率降序输出
public class CharacterCountTest {
    public static void test(){
    String s="abdc2223333ddd";
    Map<Character, Integer> map=new HashMap<Character, Integer>();
    char[] arr=s.toCharArray();
    for(char c:arr){
        if(map.containsKey(c)){
            map.put(c,map.get(c) + 1);
        }else{
            map.put(c, 1);
        }
    }
    List<Map.Entry<Character, Integer>> list=new ArrayList<Map.Entry<Character,Integer>>();
    for(Map.Entry<Character, Integer> me:map.entrySet()){
        list.add(me);
    }
    Collections.sort(list,new Comparator<Map.Entry<Character,Integer>>(){
    	public int compare(Entry<Character,Integer> o1,Entry<Character,Integer> o2){
    		//降序
    		return o2.getValue().compareTo(o1.getValue());
    	}
    });
    for(Map.Entry<Character, Integer> me:list){
        System.out.println(me.getKey()+"="+me.getValue());
    }
}
    public static void main(String[] args) {
        test();
    }
}


# 剑指 Offer 48. 最长不含重复字符的子字符串，请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。
示例 1:
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
动态规划+哈希表
class Solution{
	public int lengthOfLongestSubstring(String s) {
		Map<Character,Integer> map = new HashMap<>();
		int res = 0;
		int tmp = 0;
		for(int j = 0;j < s.length();j++){
			int i = map.getOrDefault(s.charAt(j), -1); //获取索引i
			map.put(s.charAt(j), j);     //更新哈希表
			tmp = tmp < j-i ? tmp + 1:j-i; 
			res = Math.max(res,tmp);   //max(dp[j-1],dp[j])
		}
		return res;
	}
}

#计算其不重复子串：
public static String getMax(String s){
	if(s == null || s.length() == 0){
		return null;
	}
	int start = 0 // 滑动窗口的开始值
	int maxLen = 0;
	int len = 0;
	int startMaxIndex = 0; //最长子串的开始值
	Map<Character,Integer> map = new HashMap<>();
	for(int i = 0;i < s.length();i++){
		char ch = s.charAt(i);
		if(map.containsKey(ch)){ //map中包含字符，则出现重复字符
			//下一次开始的位置是，存在map中重复字符的下一个
			start = map.get(ch) + 1; 
			//重新开始新的窗口，len置为0
			len = 0;
			//map置空
			map = new HashMap<>();
			//下磁从重复的值开始回溯
			i = value;
		}else{
			//不存在重复，就存入map
			map.put(ch , i);
			len++;
			if(len > maxLen){
				maxLen = len;
				startMaxLen = start;
			}
		}
	}
	return s.substring(startMaxLen, (startMaxLen+maxLen));
}


# 两个字符串str1、str2。str2的子字符串中包含str1的全部字符的最短长度

/*
【基本思路】
　　使用一个哈希表记录str2中每一个字符出现的次数。需要四个变量：left，right表示str1子串str1[left…right]的两边界下标，match表示在子串str1[left…right]中目前一共欠str2多少个字符。minlength记录整个遍历过程中出现的最小的子串长度。初始时，left = right = 0，match = len(str2)，minlength = 系统的最大值。
　　遍历str1，先向右扩张right，当遇到str2中的字符是，将map中相应的值 -1，同时match也 -1；如果遇到的不是str2中的字符，将(str1[right]，-1)记录到map中。当match == 0时，说明str1[left…right]已经包含了str2中的所有字符，但是此时的子串长度还不是该子串的最小长度，例如，例1中开始出现两个a，但是第二个a到c的距离才是最小距离。所以接下来还有一个向右扩张left的过程。　
　　向右扩张left，如果map[str1[left]] < 0，说明此时如果把这个字符捡起来，str1[left…right]中也不会欠str2字符，所以捡起该字符。如果map[str1[left]] == 0，说明一旦捡起该字符，那么str1[left…right]必然会欠str2一个字符，所以此时left扩张终止，此时left到right的值便是一个最小子串。　
　　令match+1，map[str1[left]]＋1，从left的下一个位置开始，继续扩张right和left寻找下一个最小的子串。整个过程中使用minlength记录最小的子串长度。　
如果str1的长度为Ｎ，该做法的时间复杂度为O(N)。
*/

 public int minLength(String str1, String str2){
        if(str1 == null || str2 ==null || str1.length() < str2.length()){
            return 0;
        }
        char[] chas1 = str1.toCharArray();
        char[] chas2 = str2.toCharArray();
        int[] map = new int[256];
        /*
		map中的状态：0初始值，>0欠缺的值，<0不欠缺的值
		*/
        for (int i=0; i< chas2.length; i++){
            map[chas2[i]]++;
        }
        int left= 0;
        int right = 0;
        int minLen =Integer.MAX_VALUE;
        int match =chas2.length;
        while (right != chas1.length){
		/*
		初始值，自减后小于0，变成欠缺的值
		欠缺的值，自减后，最小变成 0 初始值
		*/
            map[chas1[right]]--;
            if(map[chas1[right]] >= 0){
                match--;
            }
            if(match == 0){
            	//全匹配上了，开始向右移动after，after也是从0开始
                //这里可以理解为找匹配字符的最左边的位置。
                //例如：abcsfdr
                //这里找：bcd
                //此时，before已经到了d即index=5的位置
                //要计算出长度，需要知道，最左边在{bcd}中字符的位置
                //所以移动after从index=0开始，直到找到{bcd}中任意字符
                //所以after移动到b即index=1，此时最短长度为 5 - 1 + 1 = 5
                while (map[chas1[left]] < 0){
                    map[chas1[left++]]++;
                }
                minLen = Math.min(minLen, right - left + 1);
                match++;
                map[chas1[left++]]++;
            }
            right++;
        }
        return minLen == Integer.MAX_VALUE ? 0 :minLen;
    }




剑指offer:

	1、剑指 Offer 03. 数组中重复的数字，找出数组中重复的数字。
	在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。
	示例 1：
	输入：
	[2, 3, 1, 0, 2, 5, 3]
	输出：2 或 3 
	class Solution{
		public int findRepeatNumber(int[] nums){
			Set<Integer> set = new HashSet<>();
			for(int num : nums){
				if(set.contains(num)){
					return num;
				}else{
					set.add(num);
				}
			}
			return -1;
		}

	}

	2、剑指 Offer 04. 二维数组中的查找在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
	示例:
	现有矩阵 matrix 如下：
	[
	  [1,   4,  7, 11, 15],
	  [2,   5,  8, 12, 19],
	  [3,   6,  9, 16, 22],
	  [10, 13, 14, 17, 24],
	  [18, 21, 23, 26, 30]
	]
	给定 target = 5，返回 true。
	给定 target = 20，返回 false。
	class Solution{
		public boolean findNumberIn2DArray(int[][] matrix, int target){
			int row = matrix.length;
			int col = matrix[0].length;

			int i = 0;
			int j = matrix[i].length-1;
			while(i < row && j >= 0){
				if(matrix[i][j] == target){
					return true;
				}else if(matrix[i][j] < target){
					i++;
				}else{
					j--;
				}
			}
			return false;
		}
	}

	# 剑指 Offer 05. 替换空格,请实现一个函数，把字符串 s 中的每个空格替换成"%20"。
	示例 1：
	输入：s = "We are happy."
	输出："We%20are%20happy."
	class Solution{
		public String replaceSpace(String s) {
			if(s== null || s.length = 0){
				return s;
			}
			StringBuffer sb = new StringBuffer();
			for(int i = 0;i < s.length();i++){
				if(s.charAt(i) == ' '){
					sb.append("%20");
				}else{
					ab.append(s.charAt(i));
				}
			}
			return sb.toString();
		}
	}

	# 剑指 Offer 06. 从尾到头打印链表,输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。
	示例 1：
	输入：head = [1,3,2]
	输出：[2,3,1]
	class Solution {
	    public int[] reversePrint(ListNode head) {
	    	Stack<ListNode> stack = new Stack<>();
	    	while(head != null){
	    		stack.push(head);
	    		head = head.next;
	    	}
	    	int[] res = new int[stack.size()];
	    	int i = 0;
	    	while(!stack.isEmpty()){
	    		res[i++] = stack.pop().val;
	    	}
	    	return res;
	    }
    }

    #剑指 Offer 07. 重建二叉树,输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
	例如，给出
	前序遍历 preorder = [3,9,20,15,7]
	中序遍历 inorder = [9,3,15,20,7]
	返回如下的二叉树：

	    3
	   / \
	  9  20
	    /  \
	   15   7
	class Solution:
    	def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
    		if not preorder or nor inorder:
    			return None
    		root = TreeNode(preorder[0])
    		local = inorder.index(preorder[0])
    		root.left= self.buildTree(preorder[1:local+1], inorder[:local])
    		root.right = self.buildTree(preorder[local+1:], inorder[local+1:])
    		return root

    # 剑指 Offer 09. 用两个栈实现队列,用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )
    class CQueue {
	    Deque<Integer> stack1;
	    Deque<Integer> stack2;
	    
	    public CQueue() {
	        stack1 = new LinkedList<Integer>();
	        stack2 = new LinkedList<Integer>();
	    }
	    
	    public void appendTail(int value) {
	        stack1.push(value);
	    }
	    
	    public int deleteHead() {
	        // 如果第二个栈为空
	        if (stack2.isEmpty()) {
	            while (!stack1.isEmpty()) {
	                stack2.push(stack1.pop());
	            }
	        } 
	        if (stack2.isEmpty()) {
	            return -1;
	        } else {
	            int deleteItem = stack2.pop();
	            return deleteItem;
	        }
	    }
	}

	# 剑指 Offer 10- I. 斐波那契数列,写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：
	F(0) = 0,   F(1) = 1
	F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
	斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。
	答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
	示例 1：

	输入：n = 2
	输出：1
	//动态规划
	class Solution{
		public int fib(int n){
			int a = 0,b = 1,sum;
			for(int i = 0;i < n;i++){
				sum = (a+b) % 1000000007;
				a = b;
				b = sum;
			}
			return a;
		}
	}

	class Solution{
		public int fib(int n){
			if(n == 0){
				return 0;
			}
			int[] dp = new int[n+1];
			dp[0] = 0;
			dp[1] = 1;
			for(int i = 2;i < n;i++){
				dp[i] = dp[i-1] + dp[i-2];
				dp[i] %= 100000007;
			}
			return dp[n];
		}
	}
	# 剑指 Offer 10- II. 青蛙跳台阶问题,一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。
	答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
	//动态规划
	class Solution{
		public int fib(int n){
		    if (n == 0 || n == 1) {
           		return 1;
        	}
        	int[] dp = new int[n + 1];
        	dp[1] = 1;
        	dp[2] = 2;
        	for (int i = 3; i <= n; i++) {
            	dp[i] = (dp[i - 2] + dp[i - 1]) % 1000_000_007;
        	}
        	return dp[n];
        }
	}

	#剑指 Offer 11. 旋转数组的最小数字
	把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  
	示例 1：

	输入：[3,4,5,1,2]
	输出：1
	class Solution{
		public int findMinNumber(int[] arr){
			int left = 0;
			int right = arr.length - 1;
			while(left <= right){
				int mid = (left + right) >> 1;
				if(arr[mid] < arr[right]){
					right = mid;
				}else if(arr[mid] > arr[right]){
					left = mid+1;
				}else{
					j--;
				}
			}
			return arr[left];
		}
	}

	# 剑指 Offer 12. 矩阵中的路径
	请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。
	[["a","b","c","e"],
	["s","f","c","s"],
	["a","d","e","e"]]

	但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。
	示例 1：
	输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
	输出：true
	//深度优先搜索
	class Solution{
		public boolean exist(char[][] board, String word){
			char[] words = word.toCharArray();
			for(int i = 0;i < board.length;i++){
				for(int j = 0;j < board[0].length;j++){
					if(dfs(board,words,i,j,0)){
						return true;
					}
				}
			}
			return false; 
		}
		public boolean dfs(char[][] board, char[] words, int i,int j,int index){
			if(i < 0|| j < 0 || i >= board.length || j >= board[0].length || board[i][j] != words[index]){
				return false;
			}
			//结束条件，找到字符数组中的最后一个
			if(index == words.length-1){
				return true
			}
			char tmp = board[i][j];
			//标记已经用过的
			board[i][j] = '.'
			boolean res = dfs(board,words,i+1,j,index+1) || dfs(board,words,i-1,j,index+1) || dfs(board,words,i,j-1,index+1) || dfs(board,words,i,j+1,index+1)
			//重置
			board[i][j] = tmp;
			return res;
		}
	}

	# 剑指 Offer 13. 机器人的运动范围
	地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？
	示例 1：

	输入：m = 2, n = 3, k = 1
	输出：3
		public int movingCount(int m, int n, int k) {
		    //临时变量visited记录格子是否被访问过
		    boolean[][] visited = new boolean[m][n];
		    return dfs(0, 0, m, n, k, visited);
		}

		public int dfs(int i, int j, int m, int n, int k, boolean[][] visited) {
		    //i >= m || j >= n是边界条件的判断， sum(i, j) > k判断当前格子坐标是否
		    // 满足条件，visited[i][j]判断这个格子是否被访问过
		    if (i >= m || j >= n || sum(i, j) > k || visited[i][j])
		        return 0;
		    //标注这个格子被访问过
		    visited[i][j] = true;
		    //沿着当前格子的右边和下边继续访问
		    return 1 + dfs(i + 1, j, m, n, k, visited) + dfs(i, j + 1, m, n, k, visited);
		}

		//计算两个坐标数字的和
		private int sum(int i, int j) {
		    int sum = 0;
		    while (i != 0) {
		        sum += i % 10;
		        i /= 10;
		    }
		    while (j != 0) {
		        sum += j % 10;
		        j /= 10;
		    }
		    return sum;
		}

	剑指 Offer 14- I. 剪绳子
	给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

	示例 1：

	输入: 2
	输出: 1
	解释: 2 = 1 + 1, 1 × 1 = 1
	示例 2:

	输入: 10
	输出: 36
	解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
	class Solution{
		public int cuttingRope(int n) {
			if(n <= 3){
				return n-1;
			}
			int a = n / 3;
			int b = n % 3;
			if(b == 0){
				return (int)Math.pow(3,a);
			}else if(b == 1){
				return (int)Math.pow(3,a-1)*4;
			}else{
				return (int)Math.pow(3,a)*2;
			}
		}
	}
	#剑指 Offer 14- II. 剪绳子 II
	给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m - 1] 。请问 k[0]*k[1]*...*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

	答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

	示例 1：
	输入: 2
	输出: 1
	解释: 2 = 1 + 1, 1 × 1 = 1
	class Solution{
		public int cutting(int n){
			if(n <=3 ){
				return n-1;
			}
			int mod = (int)1e9 + 7;
			long res = 1;
			while(n > 4){
				res *= 3;
				res %= mod;
				n -= 3;
			}
			return (int)(res * n % mod);

		}
	}

	#剑指 Offer 15. 二进制中1的个数
	请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。
	示例 1：
	输入：00000000000000000000000000001011
	输出：3
	解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
	class Solution{
		public int hammingWeight(int n){
			int res = 0;
			while(n != 0){
				res++;
				n = n & (n-1);
			}
			return res;
		}
	}

	# 剑指 Offer 16. 数值的整数次方
实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。
	示例 1:

	输入: 2.00000, 10
	输出: 1024.00000
	//二分 递归
	class Solution{
		public double myPow(double x, int n){
			if(n == 0){
				return 1;
			}
			if(n < 0){
				return myPow(1/x, -n);
			}
			return (n%2 == 0) ? myPow(x*x,n/2):x*myPow(x*x,n/2);
		}
	}

	#剑指 Offer 18. 删除链表的节点,给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。
	返回删除后的链表的头节点。
	注意：此题对比原题有改动
	示例 1:

	输入: head = [4,5,1,9], val = 5
	输出: [4,1,9]
	解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
	class Solution {
	    public ListNode deleteNode(ListNode head, int val) {
	    	if(head == null){
	    		return head;
	    	}
	    	if(head.val == val){
	    		return head.next;
	    	}
	    	ListNode pre = null;
	    	ListNode cur = head;
	    	while(cur != null && cur.val != val){
	    		pre = cur;
	    		cur =cur.next;
	    	}
	    	pre.next = cur.next;
	    	return head;
	    }
    }

    # 算法题字符串匹配问题，*能代替若干字符，？能匹配任意一个字符，求两字符串是否匹配？
    /*
    解题思路
假设主串为 AA，模式串为 BB 从最后一步出发，需要关注最后进来的字符。假设 AA 的长度为 nn ，BB 的长度为 mm ，关注正则表达式 BB 的最后一个字符是谁，它有三种可能，正常字符、*∗ 和 .（点），那针对这三种情况讨论即可，如下：
	如果 BB 的最后一个字符是正常字符，那就是看 A[n-1]A[n−1] 是否等于 B[m-1]B[m−1]，相等则看 A_{0..n-2}A 
0..n−2与 B_{0..m-2}B 0..m−2 ，不等则是不能匹配，这就是子问题。

	如果 BB 的最后一个字符是.，它能匹配任意字符，直接看 A_{0..n-2}A 
0..n−2	与 B_{0..m-2}B 0..m−2
	如果 BB 的最后一个字符是*它代表 B[m-2]=cB[m−2]=c 可以重复0次或多次，它们是一个整体 c*c∗
		情况一：A[n-1]A[n−1] 是 00 个 cc，BB 最后两个字符废了，能否匹配取决于 A_{0..n-1}A 
0..n−1和 B_{0..m-3}B 0..m−3是否匹配
		情况二：A[n-1]A[n−1] 是多个 cc 中的最后一个（这种情况必须 A[n-1]=cA[n−1]=c 或者 c='.'c= ′.′），所以 AA 匹配完往前挪一个，BB继续匹配，因为可以匹配多个，继续看 A_{0..n-2}A 0..n−2和 B_{0..m-1}B 0..m−1是否匹配。

    */
    class Solution {
    public boolean isMatch(String A, String B) {
        int n = A.length();
        int m = B.length();
        boolean[][] f = new boolean[n + 1][m + 1];

        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= m; j++) {
                //分成空正则和非空正则两种
                if (j == 0) {
                    f[i][j] = i == 0;
                } else {
                    //非空正则分为两种情况 * 和 非*
                    if (B.charAt(j - 1) != '*') {
                        if (i > 0 && (A.charAt(i - 1) == B.charAt(j - 1) || B.charAt(j - 1) == '.')) {
                            f[i][j] = f[i - 1][j - 1];
                        }
                    } else {
                        //碰到 * 了，分为看和不看两种情况
                        //不看
                        if (j >= 2) {
                            f[i][j] |= f[i][j - 2];
                        }
                        //看
                        if (i >= 1 && j >= 2 && (A.charAt(i - 1) == B.charAt(j - 2) || B.charAt(j - 2) == '.')) {
                            f[i][j] |= f[i - 1][j];
                        }
                    }
                }
            }
        }
        return f[n][m];
    }


    # 剑指 Offer 21. 调整数组顺序使奇数位于偶数前面
	输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。
	示例：
	输入：nums = [1,2,3,4]
	输出：[1,3,2,4] 
	注：[3,1,2,4] 也是正确的答案之一。
		//双指针
		class Solution {
		    public int[] exchange(int[] nums) {
		        int left = 0;
		        int right = nums.length - 1;
		        while (left < right) {
		            // 当找到一个偶数时，就跳出循环。
		            // (这里有个求奇偶数的小技巧，就是当一个数是奇数时，它的二进制表示的最后一位肯定是1
		            while (left < right && (nums[left] & 1) == 1) {
		                left++;
		            }
		            // 当找到一个奇数时，就跳出循环
		            while (left < right && (nums[right] & 1) == 0) {
		                right--;
		            }
		            // 如果两个指针还没有碰到一起时，说明找到了需要交换的位置
		            if (left < right) {
		                int temp = nums[left];
		                nums[left] = nums[right];
		                nums[right] = temp;
		            }
		        }
		        return nums;
    		}
		}

	# 剑指 Offer 22. 链表中倒数第k个节点
	输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。
	示例：
	给定一个链表: 1->2->3->4->5, 和 k = 2.
	返回链表 4->5.
	class Solution{
		public ListNode getKthFromEnd(ListNode head, int k) {
			if(head == null){
				return null;
			}
			ListNode fast = head;
			ListNode slow = head;
			for(int i = 0;i < k;i++){
				fast = fast.next;
			}
			while(fast != null){
				fast = fast.next;
				slow = slow.next;
			}
			return slow;
		}
	}

	# 剑指 Offer 24. 反转链表
	定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。
	示例:
	输入: 1->2->3->4->5->NULL
	输出: 5->4->3->2->1->NULL
	class Solution{
		public ListNode reverseList(ListNode head){
			if(head == null){
				return null;
			}
			ListNode pre = null;
			ListNode cur = head;
			while(cur != null){
				ListNode next = cur.next;
				cur.next = pre;
				pre = cur;
				cur = next;
			}
			return pre;
		}
	}

	#剑指 Offer 25. 合并两个排序的链表
	输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。
	示例1：

	输入：1->2->4, 1->3->4
	输出：1->1->2->3->4->4
	class Solution{
		public ListNode mergeTwoLists(ListNode l1, ListNode l2){
			ListNode dummy = new ListNode(0);
			ListNode p = dummy;
			while(l1 != null || l2 != null){
				if(l1.val < l2.val){
					p.next = l1;
					l1 = l1.next;
				}else{
					p.next = l2;
					l2 = l2.next;
				}
				p = p.next;
			}
			p.next = l1 ==null ? l2:l1;
			return dummy.next;
		}
	}

	# 剑指 Offer 30. 包含min函数的栈
定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。
//维护stack2为单调栈
class MinStack {
	
	Stack<Integer> stack1;
	Stack<Integer> stack2;
    /** initialize your data structure here. */
    public MinStack() {
    	satck1 = new Stack<>();
    	stack2 - new Stack<>();

    }
    
    public void push(int x) {
    	stack1.push(x);
    	if(stack2.isEmpty() || stack2.peek() >= x){
    		stack2.push(x);
    	}

    }
    
    public void pop() {
    	if(stack1.pop().equals(stack2.peek())){
    		stack2.pop();
    	}

    }
    
    public int top() {
    	return stack1.pop();

    }
    
    public int min() {
    	return stack2.peek();

    }
}

	# 剑指 Offer 31. 栈的压入、弹出序列
	输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。
	示例 1：
	输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
	输出：true
	解释：我们可以按以下顺序执行：
	push(1), push(2), push(3), push(4), pop() -> 4,
	push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1

	class Solution {
    	public boolean validateStackSequences(int[] pushed, int[] popped){
    		if(pushed == null || popped == null){
    			return false;
    		}
    		Stack<Integer> stack = new Stack<>();
    		int i = 0;
    		for(int num : pushed){
    			stack.push(num);
    			while(!stack.isEmpty() && stack.peek() == popped[i]){
    				stack.pop();
    				i++;
    			}
    		}
    		return stack.isEmpty();	
    	}
    }

    # 剑指 Offer 37. 序列化二叉树,请实现两个函数，分别用来序列化和反序列化二叉树。
	示例: 
	你可以将以下二叉树：

	    1
	   / \
	  2   3
	     / \
	    4   5

	序列化为 "[1,2,3,null,null,4,5]"
	class Solution:
		def serialize(self, root):
			if not root:
				return "[]"
			queue = [root]
			res = []
			while queue:
				node = queue.pop(0)
				if node:
					res.append(str(node.val))
					queue.append(node.left)
					queue.append(node.right)
				else:
					res.append("null")
			return '[' + ','.join(res)+']'
        
        

	    def deserialize(self, data):
	    	if data == "[]":
	    		return
	    	vals = data[1:-1].split(',')
	    	i = 1
	    	root = TreeNode(int(vals[0]))
	    	queue = [root]
	    	while queue:
	    		node = queue.pop(0)
	    		//先从左节点
	    		if vals[i] != "null":
	    			node.left = TreeNode(int(vals[i]))
	    			queue.append(node.left)
	    		i += 1
	    		//右节点
	    		if vals[i] != "null":
	    			node.right = TreeNode(int(vals[i]))
	    			queue.append(node.right)
	    		i += 1
	    	return root


    # 剑指 Offer 39. 数组中出现次数超过一半的数字,数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。你可以假设数组是非空的，并且给定的数组总是存在多数元素。
	示例 1:
	输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]
	输出: 2
	//摩尔根投票法
	class Solution{
		public int majorityElement(int[] nums){
			int x = 0;
			int vote = 0;
			for(int num : nums){
				if(vote == 0){
					x = num;
				}
				vote += num == x ? 1:-1;
			}
			return x;
		}
	}

	# 剑指 Offer 40. 最小的k个数,输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。
	示例 1：
	输入：arr = [3,2,1], k = 2
	输出：[1,2] 或者 [2,1]
	/*
	大根堆 top K
	定义堆并重写比较器，默认是放大的
	遍历数组，个数小于k就往里添加
	堆顶元素>新元素，就弹出，并添加新元素
	*/
	class Solution{
		public int[] getLeastNumbers(int[] arr, int k){
			if(k == 0 || arr.length == 0){
				return new int[0];
			}
			//堆--重新比较器，默认是小根堆
			Queue<Integer> pq = new PriorityQueue<>((v1,v2) -> v2-v1);
			for(int num : arr){
				if (pq.size() < k){
					pq.offer(num);
				}else if(pq.peek() > num){
					pq.poll();
					pq.offer(num);
				}

			}
			//返回堆中的元素
			int[] res = new int[k];
			int i = 0;
			for(int num : pq){
				res[i++] = num;
			}
			return res;
		}
	}

	#前 K 个高频元素,给定一个非空的整数数组，返回其中出现频率前 k 高的元素。
	示例 1:
	输入: nums = [1,1,1,2,2,3], k = 2
	输出: [1,2]
	示例 2:
	输入: nums = [1], k = 1
	输出: [1]
	class Solution{
		public List<Integer> topKfrequent(int[] nums, int k){
			HashMap<Integer,Integer> map = new HashMap<>();
			for(int num : nums){
				if(map.containsKey(num)){
					map.put(num,map.get(num) + 1);
				}else{
					map.put(num,1);
				}
			}

			PriorityQueue<Integer> pq = new PriorityQueue<>((v1,v2) -> map.get(v1) - map.get(v2));
			for(int key : map.keySet()){
				if(pq.size() < k){
					pq.offer(key);
				}else if(map.get(key) > map.get(pq.peek())){
					pq.poll();
					pq.offer(key);
				}
			}
			List<Integer> list = new ArrayList<>();
			while(!pq.isEmpty()){
				list.add(pq.poll())
			}
			return list;
		} 
	}

	数组中的第K个最大元素,在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
	示例 1:
	输入: [3,2,1,5,6,4] 和 k = 2
	输出: 5
	class Solution{
		public int findKthLargest(int[] nums,int k){
			PriorityQueue<Integer> pq = new PriorityQueue<>();
			for(int num : nums){
				pq.offer(num);
				if(pq.size() > k){
					pq.poll();
				}
			}
			return pq.peek();
		}
	}

	

	#剑指 Offer 42. 连续子数组的最大和,输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。
	示例1:

	输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
	输出: 6
	解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
	class Solution{
		public int maxSubArray(int[] nums){
			int res = nums[0];
			if(nums.length == 0 || nums == null){
				return res;
			}
			int sum = 0;
			for(int num : nums){
				if(sum > 0){
					sum += num;
				}else{
					sum = num;
				}
				res = Math.max(sum,res);
			}
			return res;
		}
	}

	#剑指 Offer 43. 1～n整数中1出现的次数,输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。
	示例 1：

	输入：n = 12
	输出：5
	class Solution{
		public int countDigitOne(int n){

		}
	}

	剑指 Offer 45. 把数组排成最小的数，输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。
	示例 1:
	输入: [10,2]
	输出: "102"
	示例 2:
	输入: [3,30,34,5,9]
	输出: "3033459"
	/*
	用list来装转换成字符串的数组，
	然后用list排序，重写排序方法，升序排序
	拼接字符串shuchu
	*/
	class Solution{
		public String minNumber(int[] nums){
			List<String> list = new ArrayList<>();
			for(int num : nums){
				list.add(String.valueOf(num)); //将int转为string添加到list中
			}
			//自定义排序方法，升序
			list.sort((o1,o2) -> (o1+o2).compareTo(o2+o1));
			//拼接为字符串
			return String.join("",list);
		}
	}

	剑指 Offer 46. 把数字翻译成字符串，给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。
	示例 1:
	输入: 12258
	输出: 5
	解释: 12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"
	/*
	动态规划
	将数字转换成字符串
	创建动态规划数组
	定义初始值
	substring(i-2,i)
	*/
	class Solution{
		public int translateNum(int num) {
			//将数组转换为string
			String s = String.valueOf(num);
			int[] dp = new int[s.length() + 1];
			dp[0] = 1;
			dp[1] = 1;

			for(int i = 2;i <= s.length();i++){
				String tmp = s.substring(i-2,i);
				//字符串比较
				if(tmp.compareTo("10") >= 0 && tmp.compareTo("25") <= 0){
					dp[i] = dp[i-1] + dp[i-2];
				}else{
					dp[i] = dp[i-1];
				}
			}
			return dp[s.length()];

    	}
	}

	剑指 Offer 47. 礼物的最大价值，在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？
	示例 1:
	输入: 
	[
	  [1,3,1],
	  [1,5,1],
	  [4,2,1]
	]
	输出: 12
	解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物
	class Solution{
		public int maxValue(int[][] grid) {
			int m = grid.length;
			int n = grid[0].length;

			for(int i = 0;i < m;i++){
				for(int j = 0;j < n;j++){
					if(i == 0 && j == 0){
						continue;
					}else if(i == 0){//初始化第一行
						grid[i][j] += grid[i][j-1];
					}else if(j == 0){  // 初始化第一列
						grid[i][j] += grid[i-1][j];
					}else{
						grid[i][j] += Math.max(grid[i-1][j], grid[i][j-1]);
					}
				}
			}
			return grid[m-1][n-1];

    	}
	}

# 1293. 网格中的最短路径，给你一个 m * n 的网格，其中每个单元格不是 0（空）就是 1（障碍物）。每一步，您都可以在空白单元格中上、下、左、右移动。如果您 最多 可以消除 k 个障碍物，请找出从左上角 (0, 0) 到右下角 (m-1, n-1) 的最短路径，并返回通过该路径所需的步数。如果找不到这样的路径，则返回 -1。
	示例 1：
	输入： 
	grid = 
	[[0,0,0],
	 [1,1,0],
	 [0,0,0],
	 [0,1,1],
	 [0,0,0]], 
	k = 1
	输出：6
	解释：
	不消除任何障碍的最短路径是 10。
	消除位置 (3,2) 处的障碍后，最短路径是 6 。该路径是 (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) -> (3,2) -> (4,2).
	//visited访问标记数组二维+贪心：
	class Solution {
    public int shortestPath(int[][] grid, int k) {
        int m = grid.length;
        int n = grid[0].length;
        // 非法参数处理
        if (validateInputParams(k, m, n)) {
            return -1;
        }
        // 特殊场景处理
        if (m == 1 && n == 1) {
            return 0;
        }

        // BFS对于当前点的下一个点选择，如果grid[i][j]=0则有效入队列 visited[i][j]记录消除障碍次数
        // 若grid[i][j]=1则看是否还有消除障碍机会，若没有 此点丢弃
        // 若有消除障碍机会， （上一个点剩余消除障碍机会 - 1）比visited[i][j] 值比大 此点入队， 小则丢弃（贪心）
        // 例子：k=1, 坐标(0,2)可以为消除(0,1)障碍过来的 visited[0][2] = 0，搜索层级为2
        // 也可能为不消除任何障碍过来的 visited[0][2] = 1，层级为6，更新visited[0][2] = 1并入队
        // 因为到后面还需要消除障碍才能到达目标，先消除障碍走到visited[0][2] = 0的肯定到不了目标...
        // 0 1 0 0 0 1 0 0
        // 0 1 0 1 0 1 0 1
        // 0 0 0 1 0 0 1 0
        
        // 二维标记数组初始状态为-1，值记录剩余消除障碍的次数，剩余次数越多 越有价值（此处贪心，记录局部最优）
        int[][] visited = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                visited[i][j] = -1;
            }
        }
        // 初始步数为0，m=n=1的特殊场景已处理
        int minSteps = 0;

        // 初始位置标记已访问,值记录剩余消除障碍物次数  越多越好
        // 1. 对于其他路径到达此点且剩余消除障碍物次数小于等于当前值 —— 剪枝
        // 2. 对于其他路径到达此点且剩余消除障碍物次数大于当前值 —— 取代并入队
        visited[0][0] = k;
        Queue<Point> queue = new LinkedList<>();
        Point startPoint = new Point(0, 0, 0);
        queue.offer(startPoint);
        
        // 定义四个方向移动坐标
        int[] dx = {1, -1, 0, 0};
        int[] dy = {0, 0, 1, -1};
        // BFS搜索-队列遍历
        while (!queue.isEmpty()) {
            minSteps++;
            // BFS搜索-遍历相同层级下所有节点
            // 当前队列长度一定要在循环外部定义，循环内部有插入对列操作
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                Point current = queue.poll();
                int x = current.x;
                int y = current.y;
                int oneCount = current.oneCount;

                // 对当前节点四个方向进行识别处理
                for (int j = 0; j < 4; j++) {
                    int xNew = x + dx[j];
                    int yNew = y + dy[j];
                    // 越界判断
                    if (xNew < 0 || xNew >= m || yNew < 0 || yNew >= n) {
                        continue;
                    }
                    // 搜索到目标节点直接返回结果，按层级就是最短步数
                    if (xNew == m - 1 && yNew == n - 1) {
                        return minSteps;
                    }
                    // 穿越障碍次数已满
                    if (grid[xNew][yNew] == 1 && oneCount >= k) {
                        continue;
                    }
                    int oneCountNew = grid[xNew][yNew] == 1 ? oneCount + 1 : oneCount;
                    // 剪枝 - 节点已被访问过，且当前visited记录的剩余障碍物消除次数 >= 当前搜索节点层级的剩余消除次数
                    if (visited[xNew][yNew] != -1 && visited[xNew][yNew] >= k - oneCountNew) {
                        continue;
                    } else {
                        // 否则，贪心将最优值更新，并将该层级节点入队
                        visited[xNew][yNew] = k - oneCountNew;
                    }
                    queue.offer(new Point(xNew, yNew, oneCountNew));
                }
            }
        }
        // BFS没搜索到目标，返回-1
        return -1;
    }

    private boolean validateInputParams(int k, int m, int n) {
        return m > 40 || m < 1 || n > 40 || n < 1 || k < 1 || k > m * n;
    }

    class Point {
        int x;
        int y;
        int oneCount;

        public Point(int x, int y, int oneCount) {
            this.x = x;
            this.y = y;
            this.oneCount = oneCount;
        }
    }
}


	#剑指 Offer 49. 丑数，我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。
	示例:

	输入: n = 10
	输出: 12
	解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
	class Solution {
	    public int nthUglyNumber(int n) {
	    	if(n <= 0){
	    		return 0;
	    	}
	    	int n2 = 0;
	    	int n3 = 0;
	    	int n5 = 0;
	    	List<Integer> list = new ArrayList<>();
	    	list.add(1);
	    	while(list.size() < n){
	    		int num2 = 2 * list.get(n2);
	    		int num3 = 3 * list.get(n3);
	    		int num5 = 5 * list.get(n5);
	    		int num = Math.min(Math.min(num2,num3),num5);
	    		list.add(num);
	    		if(num == num2){
	    			n2++;
	    		}
	    		if(num == num3){
	    			n3++;
	    		}
	    		if(num == num5){
	    			n5++;
	    		}
	    	}
	    	return list.get(list.size() - 1);
	    }
    }

    # 剑指 Offer 50. 第一个只出现一次的字符,在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。
	示例:
	s = "abaccdeff"
	返回 "b"
	s = "" 
	返回 " "
	class Solution{
		public char firstUniqChar(String s){
			Map<Character, Boolean> map = new HashMap<>();
			char[] c = s.toCharArray();
			for(char cc : c){
				map.put(cc, !map.containsKey(cc));
			}
			for(char c2 : c){
				if(map.get(c2)){
					return c2;
				}
			}
			return ' ';
		}
	}

	# 剑指 Offer 51. 数组中的逆序对,在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。
	示例 1:

	输入: [7,5,6,4]
	输出: 5
	// 归并排序
	class Solution{
		public int reversePairs(int[] nums){
			int len = nums.length;
			if(len < 2){
				return 0;
			}
			//一边计算逆序对的个数一边排序，所以需要将数组拷贝到新数组中
			int[] copy = new int[len];
			for(int i = 0;i<len;i++){
				copy[i] = nums[i];
			}
			//辅助数组用于归并两个有序数组
			int[] tmp = new int[len];
			return help(copy, 0, len-1, tmp);

		}

		public int help(int[] copy, int left, int right, int[] tmp){
			//递归终止条件，当区间只剩下一个元素的时候
			if(left == right){
				return 0;
			}
			int mid = (left + right) >> 1;
			int leftPairs = help(copy,left,mid,tmp);
			int rightPairs = help(copy,mid+1,right,tmp);
			//如果整个数组已经有序，则无需合并，注意这里使用小于等于
			if(nums[mid] <= nums[mid+1]){
				return leftPairs + rightPairs;
			}
			int crossPairs = mergeAndCount(copy,left,mid,right,tmp);
			return leftPairs + rightPairs + crossPairs;
		}

		private int mergeAndCount(int[] copy, int left,int mid,int right,int[] tmp){
			//将数组拷贝到新数组中，此数组则存放归并的结果
			for(int i = left;i <= right;i++){
				tmp[i] = copy[i];
			}

			int i = left;
			int j = mid+1;
			int count = 0;
			for(int k = left;k <= right;k++){
				//如果i已经超出了它的范围，只能将j归并回去
				if(i == mid+1){
					copy[k] = tmp[j];
					j++;
					//如果j已经超出了范围，只能将i归并回去
				}else if(j == right + 1){
					copy[k] = tmp[i];
					i++;
				}else if(tmp[i] <= tmp[j]){
					copy[k] = tmp[i];
					i++;
				}else{
					copy[k] = tmp[j];
					j++;
					count += (mid-i+1);
				}
			}
			return count;
		}
	}


	# 剑指 Offer 52. 两个链表的第一个公共节点，输入两个链表，找出它们的第一个公共节点。
	class Solution{
		public ListNode findCommonList(ListNode headA,ListNode headB){
			ListNode p1 = headA;
			ListNode p2 = headB;

			while(p1 != p2){
				p1 = p1==null ? headB : p1.next;
				p2 = p2==null ? headA : p2.next;
			}
			return p1;
		}
	}

	#剑指 Offer 53 - I. 在排序数组中查找数字 I统计一个数字在排序数组中出现的次数。
	示例 1:
	输入: nums = [5,7,7,8,8,10], target = 8
	输出: 2
	class Solution{
		public int findCount(int[] nums, int target){
			if(nums.length == 0 || nums == null){
				return 0;
			}
			int left = 0;
			int right = nums.length - 1;

			int count = 0;
			while(left < right){
				int mid = (left + right) >> 1;
				if(nums[mid] >= target){
					right = mid;
				}else{
					left = mid + 1;
				}
			}
			while(left < nums.length && nums[left++] == target){
				count++;
			}
			return count;
		}
	}

	#剑指 Offer 53 - II. 0～n-1中缺失的数字,一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。
	示例 1:

	输入: [0,1,3]
	输出: 2
	示例 2:

	输入: [0,1,2,3,4,5,6,7,9]
	输出: 8
	class Solution{
		public int missingNumber(int[] nums) {
			int left = 0;
			int right = nums.length-1;
			while(left <= right){
				int mid = (left + right) >> 1;
				if(nums[mid] == mid){
					left = mid+1;
				}else{
					right = mid - 1;
				}
				
			}
			return left;
		}
	}

	#剑指 Offer 54. 二叉搜索树的第k大节点,给定一棵二叉搜索树，请找出其中第k大的节点。
	示例 1:
	输入: root = [3,1,4,null,2], k = 1
	   3
	  / \
	 1   4
	  \
	   2
	输出: 4

class Solution {
    public int kthLargest(TreeNode root, int k) {
        
        // clarification:  root == null?   k <= 1?
        List<Integer> list = new ArrayList<>();
        helper(root, list);
        return list.get(list.size() - k);
    }
    
    private void helper(TreeNode root, List<Integer> list) {
        if (root == null) return;
        if (root.left != null) helper(root.left, list);
        list.add(root.val);
        if (root.right != null) helper(root.right, list);
    }

		
}

	# 剑指 Offer 56 - I. 数组中数字出现的次数
	一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。
	示例 1：
	输入：nums = [4,1,4,6]
	输出：[1,6] 或 [6,1]
	//先异或所有数，再找到异或结果里最低位的1
	class Solution{
		public int[] singleNumber(int[] nums){
			int sum = 0;
			for(int num : nums){
				sum ^= num; //所有数异或结果
			}
			//得到sum的二进制的1的最低位
			int flag = (-sum) & sum;
			int a = 0;
			int b = 0;
			for(int num : nums){
				if((flag & num)  == 0){
					a ^= num;
				}else{
					b ^= num;
				}
			}
			return new int[]{a,b};
		}
	}

	#剑指 Offer 56 - II. 数组中数字出现的次数 II,在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。
	示例 1：
	输入：nums = [3,4,3,3]
	输出：4
	示例 2：
	输入：nums = [9,1,7,9,7,9,7]
	输出：1


	# 剑指 Offer 57. 和为s的两个数字,输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。
	示例 1：

	输入：nums = [2,7,11,15], target = 9
	输出：[2,7] 或者 [7,2]
	class Solution{
		public int[] twoSum(int[] nums, int target) {
			int left = 0;
			int right = nums.length-1;
			while(left < right){
				if(nums[left] + nums[right] == target){
					return new int[]{nums[left], nums[right]};
				}else if(nums[left] + nums[right] < target){
					left++;
				}else{
					right--;
				}
			}
			return new int[]{};
    	}
	}

	# 剑指 Offer 57 - II. 和为s的连续正数序列,输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。
序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。
	示例 1：
	输入：target = 9
	输出：[[2,3,4],[4,5]]
	//左右指针滑动窗口，同向前进
	class Solution{
	    public int[][] findContinuousSequence(int target) {
	    	List<int[]> res = new ArrayList<>();
	    	int left = 1;
	    	int right = 1;

	    	while(left <= target / 2){
	    		if(sum < target){
	    			sum += right;
	    			right++;
	    		}else if(sum > target){
	    			sum -= left;
	    			left++;
	    		}else{
	    			//记录结果
	    			int[] tmp = new int[right-left+1];
	    			for(int i = left;i <= right;i++){
	    				tmp[left-i] = i;
	    			}
	    			res.append(tmp);
	    			sum -= left;
	    			left++;

	    		}
	    	}
	    	return res.toArray(new int[res.size()][]);

	    }
	}

	# 剑指 Offer 58 - I. 翻转单词顺序,输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串"I am a student. "，则输出"student. a am I"。
	示例 1：

	输入: "the sky is blue"
	输出: "blue is sky the"
	class Solution{
		public String reverseString(String s){
			String[] ss = s.trim().split(" ");
			StringBuffer sb = new StringBuffer();

			for(int i = ss.length-1;i>=0;i--){
				if(ss[i].equals("")){
					continue;
				}else{
					sb.append(ss[i] + " ");
				}
				

			}
			return sb.toString().trim();
		}
	}

	#剑指 Offer 58 - II. 左旋转字符串，字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。
	示例 1：

	输入: s = "abcdefg", k = 2
	输出: "cdefgab"
	class Solution{
		public String reverseLeftWords(String s, int n){
			String ss = s+s;
			int len1 = s.length();
			int len2 = ss.length();

			return ss.substring(n,len2-(len1-n));

			//return s.substring(n,len1) + s.substring(0,n);
		}
	}

	# 剑指 Offer 59 - I. 滑动窗口的最大值,给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。
	示例:

	输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
	输出: [3,3,5,5,6,7] 
	解释: 

	  滑动窗口的位置                最大值
	---------------               -----
	[1  3  -1] -3  5  3  6  7       3
	 1 [3  -1  -3] 5  3  6  7       3
	 1  3 [-1  -3  5] 3  6  7       5
	 1  3  -1 [-3  5  3] 6  7       5
	 1  3  -1  -3 [5  3  6] 7       6
	 1  3  -1  -3  5 [3  6  7]      7
	 //双端队列，头尾尾头
	 class Solution{
	 	public int[] maxSlidingWindow(int[] nums, int k) {
	 		int len = nums.length;
	 		if(len == 0){
	 			return nums;
	 		}
            int[] res = new int[len-k+1];

	 		//创建一个双端队列，里面存的是index，不是数组的值
	 		Deque<Integer> dq = new LinkedList<>();

	 		for(int i = 0;i < len;i++){
	 			//step1移除头部，保证窗口的长度范围
	 			if(!dq.isEmpty() && dq.getFirst() < i-k+1){
	 				dq.removeFirst();
	 			}
	 			//step2，尾：移除尾部小于当前值的元素
	 			while(!dq.isEmpty() && nums[i] >= nums[dq.getLast()]){
	 				dq.removeLast();
	 			}
	 			//step3：尾部加入，滑动窗口向右扩充
	 			dq.addLast(i);
	 			
	 			//step4：头，从头部返回极大值
	 			if(i >= k-1){
	 				res[i-k+1] = nums[dq.getFirst()];
	 			}
	 		}
	 		return res;



    	}
	 }

	 #剑指 Offer 61. 扑克牌中的顺子,从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。
		示例 1:

		输入: [1,2,3,4,5]
		输出: True
		 

		示例 2:

		输入: [0,0,1,2,5]
		输出: True
		class Solution{
			public boolean isStraight(int[] nums) {

				Set<Integer> set = new HashSet<>();
				int max = 0;
				int min = 14;
				for(int num : nums){
					if(num == 0){
						continue;
					}
					max = Math.max(num,max);
					min = Math.min(num,min);
					if(set.contains(num)){
						return false;
					}
					set.add(num);
				}
				return max - min < 5;

    		}
		}


		剑指 Offer 63. 股票的最大利润,假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？
		示例 1:

		输入: [7,1,5,3,6,4]
		输出: 5
		解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
		     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
		class Solution{
			public int maxProfit(int[] prices) {
				int cost = Integer.MAX_VALUE;
				int profit = 0;

				for(int price : prices){
					cost = Math.min(cost,price);
					profit = Math.max(profit, price-cost);
				}
				return profit;

    		}
		}

		public int method(int n, int[][] input){
			int Acount = 0;
			int Bcount = 0;
			int Ccount = 0;
			//行数
			int row = input.length;

			int res = 0;
			for(int i = 0;i < row;i++){
				if(input[i][0] == 'A'){
					Acount++;
				}else if(input[i][0] == 'B'){
					Bcount++
				}else if(input[i][0] == 'C'){
					Ccount++;
				}
			}
			
			return Acount * Bcount * Count;

		}
给定一个数组，不用循环的方法，遍历这个数组
class solution{
	public static void main(String[] args) {
		int[] arr = {1,2,3,4,5};
		Print(arr,arr.length);
	}

	private static void Print(int[] arr, int length) {
		if(length > 0) {
			System.out.print(arr[length - 1]);
			Print(arr,length-1);
		}
	}
}

采用数组实现栈：
class MyStack<T> {
	//实现栈的数组
	private Object[] stack;
	//数组大小
	private int size;

	MyStack(){
		stack = new Object[10]; //初始容量为10
	}

	//判断是否为空
	public boolean isEmpty(){
		return size == 0;
	}
	//判断栈顶元素
	public T ppek(){
		T t = null;
		if(size > 0){
			t = (T) stack[size - 1];
		}
		return t;
	}
	//进栈
	public void push(T t){
		expandCapacity(size + 1);
		stack[size] = t;
		size++;
	}
	//出栈
	public T pop(){
		T t = peek();
		if(size > 0){
			stack[size - 1] = null;
			size--;
		}
		return t;
	}
	//扩大容量
	public void expandCapacity(int size){
		int len = stack.length;
		if(size > len){
			size = size * 3/2 + 1;
			stack = Arrays.copyOf(stack,size);
		}
	}

}

public class ArrayStack{
	public static void main(String[] args){
		MyStack<String> stack = new MyStack<>();
		...
	} 
}

采用链表实现栈：
/**
 * 链表实现栈
 *
 * @param <T>
 */
class Mystack2<T> {
    //定义链表
    class Node<T> {
        private T t;
        private Node next;
    }
 
    private Node<T> head;
 
    //构造函数初始化头指针
    Mystack2() {
        head = null;
    }
 
    //入栈
    public void push(T t) {
        if (t == null) {
            throw new NullPointerException("参数不能为空");
        }
        if (head == null) {
            head = new Node<T>();
            head.t = t;
            head.next = null;
        } else {
            Node<T> temp = head;
            head = new Node<>();
            head.t = t;
            head.next = temp;
        }
    }
 
    //出栈
    public T pop() {
        T t = head.t;
        head = head.next;
        return t;
    }
 
    //栈顶元素
    public T peek() {
        T t = head.t;
        return t;
    }
 
    //栈空
    public boolean isEmpty() {
        if (head == null)
            return true;
        else
            return false;
    }
}
 
public class LinkStack {
    public static void main(String[] args) {
        Mystack2 stack = new Mystack2();
        System.out.println(stack.isEmpty());
        stack.push("Java");
        stack.push("is");
        stack.push("beautiful");
        System.out.println(stack.peek());
        System.out.println(stack.peek());
        System.out.println(stack.pop());
        System.out.println(stack.pop());
        System.out.println(stack.isEmpty());
        System.out.println(stack.pop());
        System.out.println(stack.isEmpty());
    }
}

# 编辑距离：给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。
你可以对一个单词进行如下三种操作：
插入一个字符
删除一个字符
替换一个字符
示例 1：
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
/*
动态规划
相同的话，直接是对角那个
不相同的话，如果找它相邻的三个的最小值加一
*/
class Solution{

	public int minDistance(String word1,String word2){
		int[][] dp = new int[word1.length() + 1][word2.length() +1];

		//初始化列
		for(int col = 1;col < dp[0].length;col++){
			dp[0][col] = col;
		} 
		//初始化行
		for(int row = 1;row < dp.length;row++){
			dp[row][0] = row;
		}

		for(int row = 1;row < dp.length;row++){
			char char1 = word1.charAt(row-1);
			for(int col = 1;col < dp[row].length;col++){
				char char2 = word2.charAt(col-1);
				if(char1 == char2){
					dp[row][col] = dp[row - 1][col-1];
				}else{
					dp[row][col] = min(dp[row-1][col-1],dp[row-1][col],dp[row][col-1]) + 1;
				}
			}
		}

		return dp[dp.length-1][dp[dp.length-1].length - 1];
	}

	private int min(int a,int b){
		return Math.min(a,Math.min(b,c));
	}
}

#计算器，给定一个包含正整数，+，-，*，/的算法表达式（括号除外），计算其结果。表达式仅包含非负整数，四则运算符和空格。整数算法仅保留整数部分
示例 1:
输入: "3+2*2"
输出: 7
示例 2:
输入: " 3/2 "
输出: 1
/*
1.1如果num前面的是+或者-，我们就将num入栈，其中如果是-号，我们就将-num入栈，要记住，switch比的操作符是num前面的而不是
当前的char c=s.charAt(i)。
1.2如果是*/，我们就将栈中存放的num前面一个数字出栈，用该数字和num进行运算，将运算后的数字继续入栈。
每次操作完后我们将num=0，op=s.charAt(i)。
*/
class Solution{
	public int calculate(String s){
		if(s == null || s.length == 0) return 0;
		s = s.replace(" ","");
		Stack<Integer> stack = new Stack<>();
		int n = 0;
		char op = '+';
		for(int i = 0;i < s.length();i++){
			char c = s.charAt(i);
			//如果是数字的话，就将字符转换为数字
			if(Character.isDigit(c)){
				n= n*10 + (c - '0');
			}
			if(!Character.isDigit(c) || i =s.length() - 1){
				int pre;
				switch(op){
					case '+':
						stack.push(n);
						break;
					case '-':
						stack.push(-n);
						break;
					case '*':
						pre = stack.pop();
						stack.push(pre * n);
						break;
					case '/':
						pre = stack.pop();
						stack.push(pre / n);
						break;

				}
				op = c;
				n = 0;
			}
		}
		int res = 0;
		while(! starck.isEmpty()){
			res += stack.pop();
		}
		return res;
	}
}


java手写死锁：
public class DeadLock {
    public static String obj1 = "obj1";
    public static String obj2 = "obj2";
    public static void main(String[] args){
        Thread a = new Thread(new Lock1());
        Thread b = new Thread(new Lock2());
        a.start();
        b.start();
    }    
}
class Lock1 implements Runnable{
    @Override
    public void run(){
        try{
            System.out.println("Lock1 running");
            while(true){
                synchronized(DeadLock.obj1){
                    System.out.println("Lock1 lock obj1");
                    Thread.sleep(3000);//获取obj1后先等一会儿，让Lock2有足够的时间锁住obj2
                    synchronized(DeadLock.obj2){
                        System.out.println("Lock1 lock obj2");
                    }
                }
            }
        }catch(Exception e){
            e.printStackTrace();
        }
    }
}
class Lock2 implements Runnable{
    @Override
    public void run(){
        try{
            System.out.println("Lock2 running");
            while(true){
                synchronized(DeadLock.obj2){
                    System.out.println("Lock2 lock obj2");
                    Thread.sleep(3000);
                    synchronized(DeadLock.obj1){
                        System.out.println("Lock2 lock obj1");
                    }
                }
            }
        }catch(Exception e){
            e.printStackTrace();
        }
    }
}

11、回文数
class Solution{
	public boolean isPalindrome(int x){
		if(x < 0){
			return false;
		}
		int cur = 0;
		while(num != 0){
			cur = cur * 10 + num %10;
			num /= 10;
		}
		return cur == x;
	}
}

12、1000以内的完数
public class solution{
	public static void main(String[] args){
		int i,j;
		int sum = 0;
		for(int i = 1;i <= 1000;i++){
			for(int j =1;j < i;j++){
				if(i % j == 0){
					sum += j;
				}
			}
			if(sum == i){
				system.out.println(i);
			}
			sum = 0;
		}
	}
}
13、100以内的素数
public class Solution{
	public static void main(String[] args){
		
		for(int i = 2;i <= 100;i++){
			boolean flag = true;
			for(int j = 2;j <= Math.sqrt(i);j++){
				if(i % j == 0){
					flag = false;
					break;
				}
			}
			if(flag){
				System.out.print(i + ",");
			}
		}
	}
}

14、编程找出1-100之间的所有孪生素数
public class solution{
	public static void main(String[] args){
		for(int i = 2;i < 100;i++){
			if(isPrim(i) && isPrim(i + 2)){
				System.out.println(i + "," + (i+2));
			}
		}

	}
	//判断一个数是否是素数
	static boolean isPrim(int num){
		for(int i = 2; i <= Math.sqrt(num);i++){
			if(num % i == 0){
				return false;
			}
		}
		return true;
	}
}

15、求最大公约数
public class Gongyueshu {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.println("输入第一个数");
		int num1 = sc.nextInt();
		System.out.println("输入第二个数");
		int num2 = sc.nextInt();
		
		if(num1 < num2) {
			num1 = num1 ^ num2;
			num2 = num1 ^ num2;
			num1 = num1 ^ num2;
		}
		int res = gys(num1 , num2);
		System.out.println(res);

	}

	private static int gys(int num1, int num2) {
		if(num1 % num2 == 0) {
			return num2;
		}
		return gys(num2,num1 % num2);
	}

}

//求最小公倍数
public class Gongbeishu {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.println("输入第一个数");
		int num1 = sc.nextInt();
		System.out.println("输入第二个数");
		int num2 = sc.nextInt();
		int n = gys(num1,num2);
		//两个乘起来除以最大公约数
		int res = num1 * num2 / n;
		System.out.println(res);
	}
	//求最大公约数
	private static int gys(int num1, int num2) {
		if(num1 < num2) {
			num1 = num1 ^ num2;
			num2 = num1 ^ num2;
			num1 = num1 ^ num2;
		}
		if(num1 % num2 == 0) {
			return num2;
		}
		return gys(num2,num1 % num2);
	}

}

两个含有数字的字符串的相加最小值
public class xiangjia {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.println("请输入第一个字符串");
		String s1 = sc.nextLine();
		System.out.println("请输入第二个字符串");
		String s2 = sc.nextLine();
		
		StringBuilder sb1 = new StringBuilder();
		StringBuilder sb2 = new StringBuilder();
		for(int i = 0;i < s1.length();i++) {
			if(s1.charAt(i) >= '0'  && s1.charAt(i) <= '9') {
				sb1.append(s1.charAt(i));
			}
		}
		for(int i = 0;i < s2.length();i++) {
			if(s2.charAt(i) >= '0'  && s2.charAt(i) <= '9') {
				sb2.append(s2.charAt(i));
			}
		}
		List<Integer> list1 = new ArrayList<>();
		for(char c : sb1.toString().toCharArray()) {
			list1.add(c - '0');
		}
		List<Integer> list2 = new ArrayList<>();
		for(char c : sb2.toString().toCharArray()) {
			list2.add(c - '0');
		}
		list1.sort((o1,o2) -> (o1-o2));
		list2.sort((o1,o2) -> (o1-o2));
		String ss1 = "";
		for(int num : list1) {
			ss1 += num;
		}
		String ss2 = "";
		for(int num : list2) {
			ss2 += num;
		}
		System.out.println(Integer.parseInt(ss1) + Integer.parseInt(ss2));		

	}

}




13、ip地址：
class Solution {
  public String validateIPv4(String IP) {
    String[] nums = IP.split("\\.", -1);
    for (String x : nums) {
      // Validate integer in range (0, 255):
      // 1. length of chunk is between 1 and 3
      if (x.length() == 0 || x.length() > 3) return "Neither";
      // 2. no extra leading zeros
      if (x.charAt(0) == '0' && x.length() != 1) return "Neither";
      // 3. only digits are allowed
      for (char ch : x.toCharArray()) {
        if (! Character.isDigit(ch)) return "Neither";
      }
      // 4. less than 255
      if (Integer.parseInt(x) > 255) return "Neither";
    }
    return "IPv4";
  }

  public String validateIPv6(String IP) {
    String[] nums = IP.split(":", -1);
    String hexdigits = "0123456789abcdefABCDEF";
    for (String x : nums) {
      // Validate hexadecimal in range (0, 2**16):
      // 1. at least one and not more than 4 hexdigits in one chunk
      if (x.length() == 0 || x.length() > 4) return "Neither";
      // 2. only hexdigits are allowed: 0-9, a-f, A-F
      for (Character ch : x.toCharArray()) {
        if (hexdigits.indexOf(ch) == -1) return "Neither";
      }
    }
    return "IPv6";
  }

  public String validIPAddress(String IP) {
    if (IP.chars().filter(ch -> ch == '.').count() == 3) {
      return validateIPv4(IP);
    }
    else if (IP.chars().filter(ch -> ch == ':').count() == 7) {
      return validateIPv6(IP);
    }
    else return "Neither";
  }
}

 匹配子序列的单词数，给定字符串 S 和单词字典 words, 求 words[i] 中是 S 的子序列的单词个数。
示例:
输入: 
S = "abcde"
words = ["a", "bb", "acd", "ace"]
输出: 3
解释: 有三个是 S 的子序列的单词: "a", "acd", "ace"。
class Solution {
    public int numMatchingSubseq(String S, String[] words) {
        Map<Character, Deque<String>> map = new HashMap<>();
        for (char c = 'a'; c <= 'z'; c++) {
            map.put(c, new LinkedList<String>());
        }
        for (String w : words) {
            map.get(w.charAt(0)).addLast(w);
        }
        int count = 0;
        for (char c : S.toCharArray()) {
            Deque<String> deque = map.get(c);
            int size = deque.size();
            for (int i = 0; i < size; i ++) {
                String w = deque.removeFirst();
                if (w.length() == 1) {
                    count ++;
                } else {
                    map.get(w.charAt(1)).addLast(w.substring(1));
                }
            }
        }
        return count;
    }
}

//查找字符串中某一子串出现的位置
两个字符串a b 如果b是a的子串b从a中去掉 一直去掉到a中没有b为止
public static void main(String[] args){
	Scanner sc = new Scanner(System.in);
	System.out.println("请输入字符串");
	String s1= s.nextLine();
	System.out.println("请输入子串");
	String s2 = s.nextLine();

	boolean flag = true;
	if(!s1.contains(s2)){
		flag = false;
	}
	if(flag){ // 如果存在
		int pre = 0;
		while(true){
			int pos = s1.indexOf(s2);
			if(pos == -1) break;
			System.out.print((pos + pre));//字串位置
			System.out.print(' ');
			s1 = s1.substring(pos + s2.length()); //截取
			pre += (pos+s2.length());
		}
	}else{
		System.out.printlen("不包含该子串");
	}	
}

//n个数的最大公因子
class solution{
	public static int solve(int[] nums){
        int len = nums.length;
        if(len  == 0){
            return 0;
        }else if(len == 1){
            return nums[0];
        }else {
            int res = nums[0];
            for (int i = 1; i < len; i++) {
                res = gcd(res,nums[i]);
            }
            return res;
        }

    }

    //m>=n
    public static int gcd(int m,int n){
        while(n!=0){
            int rem = m % n;
            m = n;
            n = rem;
        }
        return m;
    }
}

# 两数之和，给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。
示例:
给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
class solution{
	public int[] twoSum(int[] nums,int target){
		Map<Integer,Integer> map = new HashMap<>();
		for(int i = 0;i < nums.length;i++){
			if(map.containsKey(target - nums[i])){
				return new int[]{i,map.get(target - nums[i])};
			}else{
				map.put(nums[i],i);
			}
		}
		return new int[]{-1,-1};
	}
}

# 整数反转，给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。
示例 1:
输入: 123
输出: 321
示例 2:
输入: -123
输出: -321
class Solution{
	public int reverse(int x){
		long n = 0;
		while(x != 0){
			n = n*10 + x%10;
			x /= 10;
		}
		return (int)n == n? n:0;
	}
}

# 回文数，判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
示例 1:
输入: 121
输出: true
示例 2:
输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
class solution{
	public boolean isPalindrome(int x){
		if(x < 0){
			return false;
		}
		int y = x;
		int n = 0;
		while(y != 0){
			n = n*10 + y%10;
			y /= 10;
		}
		return x == n;
	}
}



# 字符串转换整数 (atoi)
请你来实现一个 atoi 函数，使其能将字符串转换成整数。
首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：
如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。
假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。
该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。
示例 1:
输入: "42"
输出: 42
示例 2:
输入: "   -42"
输出: -42
解释: 第一个非空白字符为 '-', 它是一个负号。我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
class Solution {
    public static int MyAtoi(String str) {
        char[] chars = str.toCharArray();
        int n = chars.length;
        int idx = 0;
        while (idx < n && chars[idx] == ' ') {
            // 去掉前导空格
            idx++;
        }
        if (idx == n) {
            //去掉前导空格以后到了末尾了
            return 0;
        }
        boolean negative = false;
        if (chars[idx] == '-') {
            //遇到负号
            negative = true;
            idx++;
        } else if (chars[idx] == '+') {
            // 遇到正号
            idx++;
        } else if (!Character.isDigit(chars[idx])) {
            // 其他符号
            return 0;
        }
        int ans = 0;
        while (idx < n && Character.isDigit(chars[idx])) {
            int digit = chars[idx] - '0';
            if (ans > (Integer.MAX_VALUE - digit) / 10) {
                // 本来应该是 ans * 10 + digit > Integer.MAX_VALUE
                // 但是 *10 和 + digit 都有可能越界，所有都移动到右边去就可以了。
                return negative? Integer.MIN_VALUE : Integer.MAX_VALUE;
            }
            ans = ans * 10 + digit;
            idx++;
        }
        return negative? -ans : ans;
        }
}

# 整数转罗马数
public class Solution {

    public String intToRoman(int num) {
        // 把阿拉伯数字与罗马数字可能出现的所有情况和对应关系，放在两个数组中
        // 并且按照阿拉伯数字的大小降序排列，这是贪心选择思想
        int[] nums = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
        String[] romans = {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};

        StringBuilder stringBuilder = new StringBuilder();
        int index = 0;
        while (index < 13) {
            // 特别注意：这里是等号
            while (num >= nums[index]) {
                // 注意：这里是等于号，表示尽量使用大的"面值"
                stringBuilder.append(romans[index]);
                num -= nums[index];
            }
            index++;
        }
        return stringBuilder.toString();
    }
}

# 罗马数转整数
class Solution {
    public int romanToInt(String s) {
		HashMap<Character,Integer> map = new HashMap<>();
		 map.put('I', 1);
		 map.put('V', 5);
		 map.put('X', 10);
		 map.put('L', 50);
		 map.put('C', 100);
		 map.put('D', 500);
		 map.put('M', 1000);
		 int res = 0;
         int i = 0;
		while(i < s.length()) {
			int num = map.get(s.charAt(i));
			if(i+1 <s.length() && map.get(s.charAt(i+1)) > num) {
				res -= num;
			}else {
				res +=num;
			}
            i++;
		}
		return res;
	}
}

# 最长公共前缀，编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 ""。
示例 1:
输入: ["flower","flow","flight"]
输出: "fl"
示例 2:
输入: ["dog","racecar","car"]
输出: ""
解释: 输入不存在公共前缀。
class solution{
	public String longestCommonPrefix(String[] strs){
		if(strs == null || strs.length == 0){
			return "";
		}
		String prefix = strs[0];
		int count = strs.length;
		for(int i = 1;i < count; i++){
			prefix = longestCommon(prefix,strs[i]);
			if(prefix.length() == 0){
				break;
			}
		}
		return prefix;
	}

	public String longestCommon(String s1,String s2){
		int length = Math.min(s1.length(),s2.length());
		int index = 0;
		while(index < length && s1.charAt(index) == s2.charAt(index)){
			index++;
		}
		return s1.substring(0,index);
	}
}

乘法表中第k小的数，几乎每一个人都用 乘法表。但是你能在乘法表中快速找到第k小的数字吗？给定高度m 、宽度n 的一张 m * n的乘法表，以及正整数k，你需要返回表中第k 小的数字。
例 1：
输入: m = 3, n = 3, k = 5
输出: 3
解释: 
乘法表:
1	2	3
2	4	6
3	6	9
第5小的数字是 3 (1, 2, 2, 3, 3).
/*	如果我们需要在第i行中寻找大于num的个数，我们只要min(num / i, n)，
其中（i是这一行的行号，n是矩阵的列数）num / i代表的是如果num也在第i行，
它存在的列数，所以只要取最小值就是第i行不大于num的个数。
（比如例题1中，我们需要知道第2行，不大于4的个数，min(4 / 2, 3) == 2个（就是2， 4））

	那么如果我们需要确定这个乘法表中不大于num的个数就非常简单了，我们只要将每一行
不大于num的个数累加即可。（比如例题1中，我们需要知道乘法表中不大于4的个数，
第一行3个、第二行2个，第三行1个）

	现在我们就可以使用二分搜索了，初始化left = 1， right = n * m + 1，
mid = （left + right） / 2，在m，n的乘法表中寻找不超过mid的个数。
*/
public int findKthNumber(int m,int n,int k){
	int l = 1;
	int r = m*n+1;
	int mid,count;
	while(l < r){
		mid = (l + r) >> 1;
		count = 0;
		for(int i = 1;i <= m;i++){
			count += (mid/i > n ? n : mid/i);
		}
		if(count >= k){
			r = mid;
		}else{
			l = mid+1; 
		}
		return l;
	}
}
// 给出4个1-10的数字，通过加减乘除，得到数字为24就算胜利
public class solution{
	public static void main(String[] args){
		List<Integer> list = new ArrayList<>();
		Scanner sc = new Scanner(System.in);
		String s = sc.nextLine();
		String[] ss = s.split(" ");
		for(int i = 0;i < 4;i++){
			list.add(Integer.parseInt(ss[i]));
		}
		boolean flag = fun(list);
		System.out.println(flag);
	}

	public static boolean fun(List<Integer> list){
		for(int i = 0;i < list.size();i++){
			int tmp = list.get(i);
			list.remove(i);
			if(getResult(list,tmp)){
				return true;
			}
			list.add(i,tmp);
		}
		return false;
	}
	private static boolean getResult(List<Integer> list,int tmp){
		if(list.size() > 0){
			for(int i = 0;i < list.size();i++){
				int n = list.get(i);
				list.remove(i);

				if(getResult(list,tmp * n) || getResult(list,tmp + n) || getResult(list,tmp - n)){
					return true;
				}else if(tmp % n == 0){
					if(getResult(list,tmp / n)){
						return true;
					}
				}
				list.add(i,n);
			}
			return false;
		}else{
			if(tmp == 24){
				return true;
			}else{
				return false;
			}
		}
	}
}
//目前有1分，3分，5分面值的硬币，要组成一个10分面值最少需要几个硬币

import java.util.*;
public class Minco {

	public static void main(String[] args) {
		int[] coins= {1,3,5};
		int amount = 10;
		int res = coinChange(coins,amount);
		System.out.println(res);
	}


	static int ans = Integer.MAX_VALUE;
	public static int coinChange(int[] coins, int amount) {
		if(amount==0){
			return 0;
		}
		dfs(coins,amount,coins.length-1,0);
		return ans==Integer.MAX_VALUE?-1:ans;
	}

	public static void dfs(int[] coins, int amount, int i, int count){
		//索引值超过数组下限时return
		if(i<0){
			return;
		}
		for(int c=amount/coins[i];c>=0;c--){//贪心 每次用最大面值硬币去拟合金额
			int temp_amount = amount-c*coins[i];
			int temp_count = c+count;
			if(temp_amount==0){//金额刚好凑够则跟之前ans比较取最小值
				ans = Math.min(ans,temp_count);
				break;
			}
			if(temp_count+1>=ans){
				break;
			}
			dfs(coins,temp_amount,i-1,temp_count);
		}
	}
}

// 单链表的头插，尾插，按指定位置插入
public class MyLinkedList{
	//内部类
	class ListNode{
		private int data;
		private ListNode next;
		public ListNode(int data){
			this.data = data;
			this.next = null;
		}
	}

	class SingleList{
	
		private ListNode head = new ListNode();

		//头插法
		public void addFirst(int data){
			ListNode node = new ListNode(data);
			if(this.head == null){
				this.head = node;
			}else{
				node.next = this.head;
				this.head = node;
			}
		}
		//尾插法
		public void addLast(int data){
			ListNode node = new ListNode(data);
			ListNode cur = head;
			if(head == null){
				head = node;
			}else{
				while(cur.next != null){
					cur = cur.next;
				}
				cur.next = node;
			}
		}

		//按照坐标进行插入
		private ListNode search(int index){
			if(index < 0){
				throw new UnsupportedOperationException("位置不合法");
			}
			int count = 0;
			ListNode cur = head;
			for(int i = 0;i < index-1;i++){
				cur = cur.next;
				count++;
			}
			return cur;
		}

		public void addIndex(int index, int data){
			if(index == 0){
				addFirst(data);
			}
			ListNode node = new ListNode(data);
			ListNode cur = search(index);
			node.next = cur.next;
			cur.next = node;

		}

		//删除某一个结点
		public void deleteList(int data){
			ListNode tmp = head;
			while(tmp.next != null && tmp.next.val != data){
				tmp = tmp.next;
			}
			tmp.next = tmp.next.next;
		}

		//修改某一结点
		public void updateList(int data,int newNumber){
			ListNode tmp = head.next;
			while(tmp != null && tmp.val != data){
				tmp = tmp.next;
			}
			tmp.val = newNumber;
		}
	}
}

链表测试：
public class lianbiao {

	public static void main(String[] args) {
		LinkedList list = new LinkedList();
		for(int i = 1;i < 5;i++) {
			list.addFirst(i);
		}
		list.print(list.head);
		list.oddEvenList(list.head);
		list.print(list.head);
		
	}
	static class ListNode {
	      int val;
	      ListNode next;
	      ListNode() {}
	      ListNode(int val) {
	    	  this.val = val;
	      }
	      ListNode(int val, ListNode next) {
	    	  this.val = val; this.next = next;
	      }
	  }
	
	
	static class LinkedList{
		ListNode head = null;
		public ListNode oddEvenList(ListNode head){
	  		if(head == null || head.next == null){
	  			return head;
	  		}
	  		ListNode point1 = head; 
	  		ListNode point2 = head.next;
	
	  		ListNode p1 = point1;
	  		ListNode p2 = point2;
	  		//根据奇偶分为两个链表
	  		while(p2 != null && p2.next != null){
	  			p1.next = p1.next.next;
	  			p2.next = p2.next.next;
	  			p1 = p1.next;
	  			p2 = p2.next;
	  		}
	  		//将两个链表连起来
	  		p1.next = point2;
	  		return point1;
	  	}
		
		//头插法
		public void addFirst(int data) {
			ListNode node = new ListNode(data);
			if(head == null) {
				head = node;
			}else {
				node.next = head;
				head = node;
			}
		}
		
		public void print(ListNode head) {
			if(head == null) {
				return;
			}
			while(head != null) {
				System.out.println(head.val);
				head = head.next;
			}
		}
	}	 

}


DFS :

def dfs(node):
	if not node:
		return
	s = set()
	stack = []
	print(node.val)
	s.add(node)
	stack.append(node)

	while stack:
		cur = stack.pop()   # 弹出最近入栈的结点
		for next in cur.nexts: # 遍历该节点的邻接结点
			if next not in s:  # 如果邻接结点不重复
				stack.append(cur) # 把结点压入
				stack.append(next) #
				s.add(next)
				print(next.val)
				break

BFS:

def bfs(node):
	if not node:
		return
	queue = []
	s = set()
	queue.insert(0,node)
	s.add(node)
	while queue:
		cur = queue.pop()
		print(cur.val)
		for next in cur.nexts:
			if next not in s:
				s.add(next)
				queue.insert(0,next)

实现两个线程交替打印你好：
	public class MultiXiancheng {

	
	private static String str = "你好";
	private static int index = 0;
	private static final Object lock = new Object();
	
	public static void main(String[] args) {
		new Thread(() -> {
			while(index < 104) {
				synchronized(lock) {
					try {
						if(index % 2 == 1) {
							lock.wait();
						}else {
							System.out.print(str.charAt(index % str.length()));
							index++;
						}
					}catch(Exception e) {
						e.printStackTrace();
					}finally {
						lock.notify();
					}
				}
			}
		}).start();
		
		new Thread(()->{
			while(index < 104) {
				synchronized(lock) {
					try {
						if(index % 2 == 0) {
							lock.wait();
						}else {
							System.out.print(str.charAt(index % str.length()));
							index++;
							if(index % str.length() == 0) {
								System.out.println();
							}
						}
					}catch(Exception e) {
						e.printStackTrace();
					}finally {
						lock.notify();
					}
				}
			}
		}).start();
	}

}
//runnable实现两个线程交替打印你好：
public class test12 {
	private static int index = 0;
	public static void main(String[] args) {
		
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                while (index < 10) {
                    synchronized (this) {
                        notify();
 
                        System.out.println(Thread.currentThread().getName());
                        index++;
                        try {
                            Thread.sleep(500);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
 
                        try {
                            wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        };
 
        Thread threadA = new Thread(runnable, "thread-a");
        Thread threadB = new Thread(runnable, "thread-b");
        threadA.start();
        threadB.start();
    }

}

实现两个线程交替打印两个数组中的元素：
import java.util.concurrent.locks.LockSupport;

public class TwoXiancheng {

	public static void main(String[] args) {
        final Object obj = new Object();
        char[] number = {'1','2','3','4','5','6','7','8','9'};
        char[] letter = {'A','B','C','D','E','F','G','H','I'};

        new Thread(() -> {
            synchronized (obj){
                for(char num : number){
                    System.out.print(num + " ");
                    try {
                        obj.notify(); //叫醒其他线程，这里就是t2
                        obj.wait(); //让自己阻塞，让出锁
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                obj.notify(); //必须要有，因为两个线程的try里面的最后一步是阻塞，如果线程执行完了还在阻塞肯定不对，必须要唤醒，才能正确结束程序
            }
        }).start();

        new Thread(() -> {
            synchronized (obj){
                for(char let : letter){
                    System.out.print(let + " ");
                    try {
                        obj.notify(); //叫醒其他线程，这里是t1
                        obj.wait(); //让自己阻塞，让出锁
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                obj.notify(); //同上
            }
        }).start();
	}
}

用动态规划求解的基本特征：
	1，最优子结构
母问题的最bai优du解包含其子问题的最优解，我们就称此问题具有最优子结构。即也就是说，子问题最优时，母问题通过优化一定能求得最优解
	2，子问题重叠
子问题本质上是和母问题一样的，只是问题的输入参数不一样，就可以称之为子问题重叠，这是动态规划解决问题的高效的本质所在，我们可以利用很多子问题具有相同的输入参数这一个性质，来减少计算量。
	3，问题存在边界
子问题在一定情况下就不存在子问题了， 我们称这种情况为问题存在边界，对于自顶向上和自底向下的方法，边界分别是问题的出口和入口。
	4，子问题相互独立
个子问题在求解最优解时事相互独立的，即本自问题的求解和其他平行子问题是不相干的。当平行子问题解决后，选择权交给母问题时，它才会考虑各子问题之间的关系，是求最大值还是最小值，还是要做相关的运算得到母问题的最优解。

	1.求最大值/最小值

	2.求可不可行

	3.求方案总数

        








	




















