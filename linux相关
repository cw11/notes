linux相关

1、grep搜索：
	grep 搜索不包含关键字的行：grep -v down -v 是不显示匹配上的内容 ，显示不包含down的内容。
	grep 搜索包含关键字的行: grep down
	查找目录下的所有文件是否含有某个字符串： grep -rn "要查找的字符串" *
		-r 递归查找
		-n 显示行号

2、linux中top和free
   top 命令提供了实时的对系统处理器的状态监视，比较像 windows 下的任务管理器
   free来查看内存使用情况,打印出的内存信息主要分为两种，一种是安装的内存，一种是用磁盘虚拟的内存

3、查看linux io的几种方法
	1. 用 top 命令 中的cpu 信息观察
	2. vmstat：vmstat 命令报告关于线程、虚拟内存、磁盘、陷阱和 CPU 活动的统计信息
	3. iostat：可以显示 CPU 和 I/O 系统的负载情况及分区状态信息
	4. iotop：是一个用来监视磁盘 I/O 使用状况的 top 类工具。iotop 具有与 top 相似的 UI，其中包括 PID、用户、I/O、进程等相关信息。  

4、linux查看进程的几个命令：
	1、查看当前终端下的命令 ： ps -ef
	2、查看所有的进程（非动态）：ps -aux
	3、查看所有的进程（动态）：top

4、linux杀死进程的两种方式
    在Linux/unix下，中止一个Java进程有两种方式，一种是kill -9 pid，一种是kill -15 pill（默认）。
    SIGNKILL（9） 的效果是立即杀死进程. 该信号不能被阻塞, 处理和忽略。
    SIGNTERM（15） 的效果是正常退出进程，退出前可以被阻塞或回调处理。并且它是Linux缺省的程序中断信号(默认是15)。
5、linux查看最近30分钟的当前目录下的php文件
	find ./ '*.php' -mmin -30
6、查找最近24小时修改的当前目录下的.php文件
	find . -name '*.php' -mtime 0
7、wc
	wc -l 统计有多少行
	wc -w 统计有多少个单词
	wc -c 统计有多少个字符
8、暂停一个运行中的进程：kill stop pid
9、恢复其运行：kill cont pid
10、找出某个端口号被哪个进程使用 ：netstat -anp | grep 8080
10、打印列
	1、打印文件的第一列(域) ： awk '{print $1}' filename
	2、打印文件的前两列(域) ： awk '{print $1,$2}' filename
	3、打印完第一列，然后打印第二列 ： awk '{print $1 $2}' filename
	4、打印文本文件的总行数 ： awk 'END{print NR}' filename
	5、打印文本第一行 ：awk 'NR==1{print}' filename
	6、打印文本第二行第一列 ：sed -n "2, 1p" filename | awk 'print $1'
11、linux 一个文件，有两列数据，第一列是时间戳，第二列是IP地址，统计出有多少个不同的IP
    cat demo.txt | awk '{print $2}' | uniq -c
    awk '{sum[$2]++END{for ip in sum[ip]}' access_log | sort -rn -k 2
    $2代表第二个参数，-r逆序，-n用数值作比较 -k 2 按照第二列排序，第二列为sum[ip]
    awk ‘{i=$2;count[i]++}END{for(i in count)print(i,count[i])}’ /var/log/httpd/access_log
    
12、uniq工具
    uniq用于去除连续的重复行
    选项：
        -i ：忽略大小写
        -c：统计重复行次数
        -d:  只显示重复行 
13、一个文本有学号、姓名、成绩，如何实现读取文本，并插入到数据库中：
    # ！/bin/bash
    # read file an create INSERT statements for MYSQL

    out = 'stu.sql'
    IFS=','   内部字段分隔符，默认是空格换行的tab键
    while read id name score
    do
        cat >> $out << EOF
        INSERT INTO student (id name score) VALUES
        ('$id', '$name', '$score');
    EOF
    done
    其中>>追加重定向
    EOF自定义终止符
14、Linux文本替换命令
    cat 1.txt | sed -r "/s/127/127dhfus/g" > 2.txt
    s/后跟“被替换的内容”、“替换成的内容”
    1.txt为需要替换的文本
    2.txt为保存成的文本
7、软链接和硬链接：
	硬链接的特点：
		（1）不论是修改源文件，还是修改硬链接文件，另一个文件中的数据都会发生改变
		（2）不论删除源文件，还是删除硬链接文件，只要还有一个文件存在，这个文件都可以被访问
		（3）硬链接不会建立新的inode信息，也不会更改inode的总数
		（4）硬链接不能跨文件系统建立，因为在不同的文件系统中，inode号是重新计算的
		（5）硬链接不能链接目录，因为如果给目录建立硬链接，那么不仅目录本身需要重新建立，目录下所有的子文件，包括子目录中的所有子文件都需要建立硬链接，这对当前的linux来讲过于复杂
	软连接特点：
		不论是修改源文件（check），还是修改硬链接文件（check-soft)，另一个文件中的数据都会发生改变。
		删除软链接文件，源文件不受影响。而删除原文件，软链接文件将找不到实际的数据，从而显示文件不存在。
		软链接会新建自己的 inode 信息和 block，只是在 block 中不存储实际文件数据，而存储的是源文件的文件名及 inode 号。
		软链接可以链接目录。
		软链接可以跨分区。

linux详细
目录介绍：
/表示的是根的意思
/bin：存放二进制文件，是给普通用户使用的
/etc: linux下的所有配置文件都会存放在etc目录
/home: 是所有非root用户家目录的一个集合
/root：root用户的家目录
/sbin:super bin（其实是shell bin）,只能是超级管理员运行
/uer: 存放着一些用户自己安装的软件，其实类似于windows下的program files目录
/var: (variable)存放着linux下的一些日志文件，在实际开发的时候有一些公司也习惯把            apache或者nginx的站点目录放在这个目录里

常用的shell: bash
#:  超级管理员(root)
$:  普通用户

通用语法格式：# 指令名称 [选项] 操作目标/操作对象 
#ls [路径]：列出指定路径下的文件夹和文件的名字
#ls -l [路径]：以列表的形式列出指定路径下的文件夹和文件的名字
#ls -la [路径]：以列表的形式列出指定路径下的文件夹和文件名（包含隐藏文件，特点是.开头的名字）
#clear:清空当前屏幕,
快捷键 ctrl L也是清屏的意思
su 用户名: 切换用户
su ：不写用户名默认切换到root
cd 需要切换到的路径（路径可以是相对路径，也可以是绝对路径）：切换盘符
~：表示当前目录的家
注意：低级用户没有权限访问高级用户相关的资源
关于路径：
相对路径是相对当前路径的一种表现形式：只要不是以/开头的就是相对路径
绝对路径是直接从“根”开始的一种路径形式：以/开头的路径称之为绝对路径
pwd: 打印当前的工作路径
ctrl c: 取消当前命令
touch 文件的名字 路径：创建文件
mkdir 文件夹名字 文件夹路径：创建文件夹
cp [-r] 需要复制的文档 需要保存的位置：复制 （-r表示递归，如果复制的是文件夹，-r必须要加）
mv 需要移动的文档（文件夹） 需要移动到的位置：移动文件（剪切+粘贴）
mv 需要操作的文档（文件夹） 换一个名字：重命名
rm [-rf] 需要删除的文档：删除（-r表示递归，文件夹必须加；-f表示强制，不要删除提示）
tail -n 文件路径: 查看一个文件的末n行,n不写就是默认10行
head -n 文件路径：查看一个文件的头n行,n不写就是默认10行
cat 文件路径1 路径2 路径3: 查看某个文件的全部内容（将内容全部输出到命令行中），正序
tac 文件路径1 路径2 路径3: 查看某个文件的全部内容，倒序
vim 文件路径：打开一个文件，显示内容，退出输入:q按下回车即可
reboot: 重启计算机
shutdown -h 时间：关机，
shutdown -h now:立即关机
halt ：关闭内存，其实就是相当于关机

du: 表示directory used
du -sh 目录路径 :显示出目录所占的磁盘空间大小的情况
        -s:    表示sumary，汇总统计
        -h：表示以较高可读性的形式显示

df: disk free:查看磁盘剩余空间
df -h：以较高可读性进行查看

free：查看内存的使用情况
free -m：表示以mb为单位查看

find ：根据条件去查询文档的所在位置
find 范围路径 选项 选项的值
常见选项：
-name 根据名字进行查询
-type：根据文档的类型进行查询  [d]：表示文件夹, [f]表示普通文件，[s]表示套接字文件
支持*通配符模糊查询

ps：查看进程
ps -ef :
-e：等价于-A，表示全部
-f：表示full，显示全部的列

查看指定进程的pid:
pgrep -l b -name
	-l 同时显示进程名和PID
	-o 当匹配多个进程时，显示进程号最小的那个
	-n 当匹配多个进程时，显示进程号最大的那个
	注：进程号越大，并不一定意味着进程的启动时间越晚

service：用来操作服务（启动/停止/重启）
service 服务名 start/stop/restart

git命令：
	git add [filename]:添加指定文件到暂存区
	git commit -m [message] : 提交暂存区到仓库区
	git branch:列出所有本地分支
	git checkout -b [branch] 新建一个分支，并切换到该分支
	git push [remote] [branch] 上传本地指定分支到远程仓库
	git poll 拉取远程仓库到本地
	git fetch 查看远程的变动

grep：搜索、过滤、主要用于对文件/内容进行筛选，选出需要的内容
grep [选项] 关键词 文件路径/内容
选项：
        -v：排除


sed：是流编辑器，按行来处理文本内容，可以将数据进行替换、删除、新增、选取等工作
语法：sed [-nefri] 命令 输入文本
-n:使用安静模式
-e:直接在指令列模式上进行sed的动作编辑
-f：直接将sed的动作写在一个档案内
-i：直接修改读取的档案内容
常用命令：
a：新增
c：取代
d：删除
i：插入
p：列印
s：取代

awk命令：与sed相比不能以行为单位，还能以列为单位
语法：awk '{pattern action}' {filenames}
pattern表示awk在数据中查找的内容，action是在找到匹配内容时所执行的一系列命令

wc：用于统计文件的各项数值（行，单词数，字节数）
wc -lwc 文档路径
-l：line行
-w：word单词数
-c：byte，字节数

scp: 远程拷贝文件的命令
scp [参数] [原路径] [目标路径]

ssh：远程登录
ssh 用户名@ip地址
然后输入密码

查看进程：ps

查看后台运行程序：setsid

杀死进程：kill -9

管道：|
必须在终端中有输出内容的指令 | 有输入的指令[要求有读取文件内容的需求]
管道前面的输出就是管道后面的输入

linux三剑客：grep、awk、sed--用来操作文本的

grep：更适合单纯的查找或匹配文本
sed：更适合编辑文本
awk：更适合格式化文本，对文本进行较复杂格式处理

grep案例：
显示所有以d开头的文件中包含test的行
grep "test" d*
显示在aa bb cc文件中匹配test的行
grep "test" aa bb cc
显示所有包含每个字符串至少有5个连续小写字符的字符串的行
grep '[a-z]\{5\}' aa

实际中，grep主要应用于日志文件

sed命令是利用脚本来处理文本文件
sed可按照脚本的指令来处理、编辑文本文件
sed主要用来自动编辑一个或多个文件

注意：sed -e是修改输出终端，sed -i才是在源文件修改

awk是一种处理文本文件的语言，是一个强大的文本分析工具

-F ：按什么来切割

生成core文件：使用ulimit
vim编辑器：
是所有unix及linux系统下标准的编辑器，类似于windows系统下的notepad编辑器，vim适合于编写代码
vim重点是光标的移动,模式切换，删除，查找，替换，复制，粘贴，撤销命令的使用

vim的三种模式：
命令模式、编辑模式（输入模式）、末行模式（尾行模式）



命令模式：
    该模式是打开文件的第一个看到的模式，打开文件即可进入
    光标快速移动
    光标移动到行首：shift+6
    光标移动到行尾：shift+4
    光标移动到首行行首：gg
    光标移动到末行行首：G
    向上翻屏：ctrl+b
    向下翻屏：ctrl+f
    定位到指定行：行号+G

    复制：
    复制光标所在行：yy
    粘贴：在想要粘贴的地方按下p键
    以光标所在行为准（包含当前行），向下复制指定行数：数字 yy
    
    剪切/删除
    剪切/删除光标所在行：dd，下面的内容上移
    剪切/删除光标所在行为准，向下删除/剪切指定的行：数字 dd
    
    撤销/恢复
    撤销：:u或者u
    恢复：ctrl + r
三种模式间的切换：
    
    

    末行模式：
        保存操作（write）
        输入“:w”保存文件
        输入  ":w 路径" 另存为 

        退出
        输入 ":q"  退出文件
        
        保存并退出
        输入":wq"
        
        强制
        输入 ":q!"  强制退出，不保存修改
    
        搜索/查找
        输入： "/关键词" 再按下回车
        
        在搜索结果中切换上/下结果：N/n
        如果需要取消高亮，则需要在末行模式中输入":nohl"--no highlight
        
        替换
        
        
        显示行号：
        :set nu
        不显示行号：
        :set nu!

编辑模式：
        
        退出：exit
用户与用户组（重点）
    linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统
    用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护
    每个用户账号都拥有一个唯一的用户和各自的密码
    用户在登录时键入正确的用户名和密码后，就能够进入系统和自己的主目录
    要想实现用户账号的管理，要完成的工作主要有如下几个方面：
        用户账号的添加、删除、修改以及用户密码的管理
        用户组的管理

    
    1、用户管理
   （1）添加用户：useradd [选项] 用户名
        选项：
        -g:   表示指定用户主（主要）组
        -G：表示指定用户的用户（附加)组
        -s：指定用户登入后所使用的shell解释器
        -u：用户的id，系统默认会从500之后按顺序分配uid
        -c：添加注释
        -d：指定用户登入时的起始目录
        -n：取消建立以用户名称为名的群组
    注意：
        在不添加选项的时候，执行useradd之后会执行一系列操作
        a、创建同名的家目录
        b、创建同名的用户组
    案例：
        useradd -g 501 -G 500 -u 666 -s /sbin/nologin -c "user lisi" lisi
        验证：tail -1 /etc/passwd
    (2)、修改用户：usermod 选项 用户名
        选项：
        -g：指定用户的用户主组
        -G：指定用户的用户附加组
        -u：用户的id，系统默认会从500之后按顺序分配
        -l：修改用户名
        -d<登入目录> ：修改用户登入时的目录
        -s<shell>：修改用户登入后所使用的shell
    案例：修改zhangsan用户用户名，改为wangma
        usermod -l  wangma  zhangsan   (注意先后)
    (3)、设置密码
        linux不允许没有密码的用户登录系统，因此前面创建的用户目前都处于锁定状态，需要设置密码之后才能登录计算机
        语法：passwd  [用户名]
        案例: 设置wanger的密码：
                passwd wanger
                根据提示输入密码
    （4）、删除用户
        语法：userdel 选项 用户名
        -r：表示删除用户的同时，删除其家目录
        userdel -r wangerma
    2、用户组管理
        每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同linux系统对用户组的规定有所不同，如linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建
        用户组的管理涉及用户组的添加、删除和修改，组的增加、删除，修改实际上就是对/etc/group文件的更新
        （1）、用户组的添加
            语法：groupadd 选项 用户组名
            常用选项：
            -g：类似用户添加里的-u，id号，如果不指定默认从500之后递增
       （2）、用户组编辑
            语法：groupmod 选项 用户组名
            -g：类似用户添加里的-u，id号，如果不指定默认从500之后递增
            -n：类似于用户修改-l，表示设置新的用户组的名称
      （3）、用户组删除
            语法：groupdel 用户组名
    提示：针对用户和用户组的管理指令，除了passwd指令之外，其他指令一般情况下只有root用户可以执行









一、权限管理
1、权限介绍（重点）
在linux中分别有读、写、执行权限

2、身份介绍（重点）
owner身份（文件所有者，默认为文档的创建者）
group身份（与文件所有者同组的用户）
others身份（其他人，相当于所有者与同组用户）
root用户（超级用户）
3、linux的权限查看
ls -l 路径  == ll 路径
    

4、权限设置（重点）
语法：chmod [选项] 权限模式 文档路径
常用选项：
-R：递归设置权限（当文件类型为文件夹的时候）
注意：如果想要给文档设置权限，操作者要么是root用户，要么就是文档的所有者
4.1、字母形式


练习：
1、设置文件夹/tmp/php的权限（如果文件夹不存在），要求权限为递归权限，并且所有者有全部权限，同组用户有读执行权限，其他用户只读权限
mkdir /tmp/php 
chmod -R u = rwx,g=rx,o=r /tmp/php 
 2、设置文件/tem/php/class.sh权限，文件如果不存在则自行创建，要求权限为所有者全部权限，同组用户读和执行权限，其他用户没有权限
  touch /tmp/php/class.sh
chmod -R u=rwx,g=rx,o=---   /tmp/php/class.sh   
3、使用普通用户在/tmp/php目录下创建test目录，设置目录权限为所有者拥有全部权限，同组用户只读，其他用户只读
    普通用户没法创建test目录
4.2、数字形式
读：r  ---4
写：w---2
执行：x--1
没有权限--0

结合权限数字的时候遵循，最短路径要求，并且最多只能出现一次
所有者（读写执行）：7
同组用户（读执行）：5
其他用户（读）：4
面试题：用超级管理员设置文档的权限命令是chmod -R 731 aaa,请问这个命令有没有什么不合理的地方？

5、属主与属组
属主：所属的用户（文件的主人）
属组：所属的用户组
制作一需要设置这个：如果有时候去删除某个用户，则该用户对应的文档的属主和属组信息就需要去修改（类似离职之前的工作交接）
5.1、chown（重点）
作用：更改文档的所属用户（change owner）
语法：chown [-R] 新的username 文档路径
5.2、chgrp（了解）
作用：更改文档所属组
语法：chgrp [-R] groupname 文档路径
6、sudo（重点）

该问题是可以被解决的，可以使用sudo命令来进行权限设置，sudo可以让管理员（root）事先定义某些特殊命令谁可以执行
默认sudo中是没有除root之外用户的规则，要想使用则先配置sudo
sudo配置文件：/etc/sudoers
该文件默认只读，不允许修改，因此不能直接修改

案例：使用admin这个用户，
admin ALL=(ALL)   /usr/sbin/useradd


补充：在普通用户下怎么查看自己具有哪些特殊权限呢
sudo -l
二、运行级别
运行模式也可以称为运行级别
在linux中存在一个进程：init（initialize，初始化），进程id是1
查看进程：ps -ef|grep init
该进程存在一个对应的配置文件：inittab(系统运行级别配置文件，位置/etc/inittab)


三、网络设置
1、ip地址查看
需要的场景：远程连接、配置相关软件时
指令：ifconfig

2、网卡配置文件
位置：/etc/sysconfig/network-scripts/ifcfg-*文件

ONBOOT：表示是否自动连接
BOOTPROTO（COL）：网卡启动之后使用的协议，一般情况下是DHCP
HWADDR：硬件地址（mac地址），计算机之间的通信都是依赖于mac地址
扩展：针对像网卡配置目录层次比较深的文件，如果需要频繁更改。可以将需要的文件设置一个快捷方式，将其放在经常操作的目录，以简化后续的打开文件操作
ln -s 原始路径 快捷方式路径
3、网络服务操作
可以通过service指令来对网络的服务进行重启/停止/启动等操作

 
补充对于单个网卡的操作
ifdown   停止某个网卡
ifup        启动某个网卡
注意：上述这些操作不要随意在服务器上运行
四、ssh
ssh（secure shell,安全外壳协议），该协议有2个常用的作用：远程连接、远程文件传输
协议使用端口号：默认是22

4.1、远程登录：
终端工具主要帮助运维人员连接远程的服务器，常见终端工具有：Xshell、secureCRT、putty等。
（1）、获取服务器ip地址，可以通过ifconfig命令进行查看，然后顺手测试ip的连接相通性
（2）、测试连通性：ping ip地址

应用：sftp文件传输
用工具fikezilla
五、软件的安装方式
在linux系统中，软件的管理方式有三种：rpm、yum、编译方式
1、rpm
优点：对于软件包的操作比较简单，通过简单指令即可操作
缺点：
    1、安装时需要自行下载软件包
    2、安装、卸载软件时需要考虑到依赖关系
    3、软件的自定义比较差，不适合有特殊需求的场景


2、yum安装
优点：
    1、快速、傻瓜式的软件管理方式
    2、在联网情况下，自动从服务器上下载软件包（内、外网服务器均可）
    3、自动解决软件依赖关系
缺点：因其底层实为rpm操作，所以丧失了对软件的自定义功能


一、linux系统进阶路线：
    linux下软件包的管理
    linux服务器基本配置
    网络基础
    linux下系统服务
    linux下磁盘管理
    shell编程
    mysql dba实战
二、文本处理工具
    1、grep工具
        grep是行过滤工具，用于根据关键字进行行过滤
    1.1、语法： # grep [选项] ‘关键字’文件名
    1.2、选项：
            (1)、颜色显示（高亮）：--color=auto 
            别名：alias grep = 'grep --color-auto'(临时的)
            grep --color=auto 'root' password
            (2)、显示行号：-n  :grep -n 'root' password
            (3)、以root开头的行：grep '^root' password
            (4)、以root结尾的行：grep 'root$' password
            (5)、不包含root的行：grep -v 'root' password
            (6)、以ftp开头的行的前3行：grep -nB 3 '^ftp' password
                    -A:后面多少行
            (7)、不区分大小写：grep -i 'root' password
    2、cut工具
        cut是列截取工具，用于列的截取
    2.1、语法：# cut 选项 文件名
    2.2、选项：
        (1)、-c：以字符为单位进行分割，截取
            截取前5个字符的列：cut -c 1-5 password
     （2)、-d:自定义分隔符，默认为制表符\t
            以:分割的第一列：cut -d : -f 1 password
        (3)、-f: 与-d一起使用，指定截取的哪个区域
    2.3、如何查看系统的运行级别：
        （1）、runlevel
          (2)、cat /etc/initab
    2.4、如何过滤运行级别
        
    3、sort工具
        sort工具用于排序，它将文件的每一行作为一个单位，从首字符向后，依次按ASCII码值进行比较，最后将他们按升序输出
        3.1、选项：
        -u:   去除重复行
        -r：降序排序，默认是升序
        -n：以数字排序，默认是按字符排序
        -t：分隔符
        -k：第N列
        3.2、
        
    4、uniq工具
        uniq用于去除连续的重复行
    4.1、选项：
        -i ：忽略大小写
        -c：统计重复行次数
        -d:  只显示重复行   
    5、tee工具
        tee工具是从标准输入读取并写入到标准输出和文件，即：双向覆盖重定向（屏幕输出|文本输入）
    5.1、选项：
        -a 双向追加重定向    
        
     6、diff工具
        diff工具用于进行比较文件的不同、目录里文件的比较
        注意：diff描述两个文件不同的方式是告诉我们怎样改变第一个文件之后与第二个文件匹配
    6.1、语法：
        diff [选项] 文件1 文件2
    6.2、选项
        -b：不检查空格
        -B：不检查空白行
        -i：不检查大小写
        -w：忽略所有空格
        -normal：正常格式显示
        -c：上下文格式显示
        -u：合并格式显示
  
  上下文：

合并格式：

     7、paste工具
        paste工具用于合并文件行
    7.1、语法：paste file1 file2
     7.2、选项：
        -d：自定义间隔符，默认是tab
        -s:   串行处理，非并行 
    8、tr工具
        tr用于字符转换，替换和删除，主要用于删除文件中控制字符或进行字符转换
          
        8.1、选项：
            -d：删除字符串1中所有输入字符
            -s：删除所有重复出现字符序列，只保留第一个；即将重复出现的字符串压缩成一个字符串
           将1.txt中的数字替换成@： tr '0-9' '@' < 1.txt
            
        9、练习：
            9.1、查看ip地址：
            (1）、ifcpnfig
            (2)、ip a
            9.2、过滤网卡的ip，并过滤出它的网络掩码
            ifconfig eth0 | grep 'mask' | cut -d: -f2 | tr -d 'a-zA-z'
    二、bash的特性
        1、命令和文件自动补全
            tab只能补全命令和文件
        2、常见的快捷键（^相当于ctrl）（重点）
            ^c :终止前台运行的程序
            ^z:将前台运行的程序挂起到后台
            ^d:退出，等价于exit
            ^l：清屏
            ^a | home:光标移到命令行的最前端
            ^e |end :光标移到命令行的后端
            ^u：删除光标前所有字符
            ^k：删除光标后所有字符
            ^r：搜索历史命令
        3、常用的通配符（重点）
            *
            
        4、bash中的引号（重点）
            

    三、shell编程模块课程目标：
        1、shell的基本语法结构
            如：变量定义、条件判断、循环语句、分支语句、函数和数组等
        2、基本正则表达式的运用
        3、文件处理三剑客：grep、sed、awk工具的使用
        4、使用shell脚本完成一些较复杂的任务
        如：服务搭建、批量处理等
        3.1、本节目标：
            熟悉掌握shell变量的定义和获取
            能够进行shell简单的四则运算
        3.2、shell介绍
        
shell不需要编译，程序在运行时由解释器翻译成机器语言

        总结：shell就是人机交互的一个桥梁--解释器
        
    3.3、什么是shell脚本：
        简单来说就是将需要执行的命令保存到文本中，按照顺序执行。它是解释型的，意味着不需要编译
        准确叙述：若干命令+脚本的基本格式+脚本特定语法+思想==shell脚本
    3.4、什么时候用到脚本
        复杂化、复杂化的工作，通过把工作的命令写成脚本，以后仅仅需要执行脚本就能完成这些工作
    3.5、shell脚本能干啥
        自动化软件部署 LAMP/LNMP/Tomcat
        自动化管理：系统初始化脚本、批量更改主机密码、推送公钥
        自动化分析处理：统计网站访问量
        自动化备份：数据库备份、日志转储
        自动化监控脚本
    3.6、如何学习shell脚本
        尽可能记忆更多的命令（记忆命令使用功能和场景）
        掌握脚本的标准格式
        必须熟悉掌握脚本的基本语法
    3.7、学习shell脚本的秘诀
        多看（看懂）-->模仿（多练）-->多思考（多写）
    3.8、shell脚本的基本写法
        （1）脚本第一行，魔法字符 #！ 指定解释器（必写）
            #! /bin/ env bash:表示以下内容使用bash解释器解析
        （2）脚本第二部分，注释（#号）说明，对脚本的基本信息进行描述
            
            （3）脚本第三部分，脚本要实现的具体内容
        3.9、shell脚本的执行方法
            注意：标准执行方式脚本必须要有可执行权限
            权限：chmod 
            chmod +x firshshell.sh
            标准：
            方式一：绝对路径+回车：/shell01/firstshell.sh
            方式二：相对路径+回车:  ./firstshell.sh
            非标准：
            bash xxx.sh   
            sourse 文件名
            -x:查看脚本运行过程
            -n:检查脚本语法

            删除/tmp/目录下的所有文件:
               rm -rf  /tmp/*
            然后在/tmp目录里创建3个目录，分别是dir1-dir3:
                mkdir /tmp/dir{1..3}
            拷贝/tec/hosts文件到刚创建的dir1目录中
                cp /etc/hosts  /tmp/dir1
            最后打印“报告首长，任务已于2019-05-05 10：10：10时间完成”
                echo "报告首长，任务已于$(date + ‘%F %T’)完成"
    四、变量  
        4.1、变量是什么
        一句话概括：变量是用来临时保存数据的，该数据是可以变化的数据
        4.2、什么时候需要定义变量
        如果某个内容需要多次使用，并且在代码中重复出现，那么可以用变量代表该内容。这样在修改内容的时候，仅仅需要修改变量的值
        在代码运作的过程中，可能会把某些命令的执行结果保存起来，后续代码需要使用这些结果，就可以直接使用这个变量
        4.3、变量如何定义
            变量名 = 变量值
            
        4.4、变量的定义规则
            变量名区分大小写
            变量名不能有特殊字符：？* #
            变量名不能以数字开头
            等号两边不能有空格
            变量名尽量做到见名知意
    5、变量的定义方式有哪些
        5.1、基本方式：变量名= 变量值    A=123
           
        5.2、命令执行结果赋值给变量
        5.3、交互式定义变量（read）
        目的：让用户自己给变量赋值，比较灵活
        语法：read 选项 变量名
        read -p "input your name:" name
        read -p -s "input your password" password
        选项：
            -p:定义提示用户的信息
            -n:定义字符数（限制变量值的长度）
            -s：不显示（不显示用户输入的内容）--密码
            -t:定义超时时间，默认单位为秒（限制用户输入变量值的超时时间）
         
    5.4、定义有类型的变量（declare）
        目的：给变量做一些限制，固定变量的类型，比如：整型、只读
        用法：declare 选项 变量名=变量值
        
    6、变量的分类
        6.1、本地变量：当前用户自定义的变量。当前进程中有效，其他进程及当前进程的子进程无效
        6.2、环境变量：当前进程有效，并且能够被子进程调用
            evn：查看当前用户的环境变量
            set：查询当前用户的所有变量（临时变量与环境变量）
            定义环境变量：
            ccc = itcast   -->下一条 export ccc 或者 export dd=itcast
            declare -x bbb=heima
            切换用户：su
        6.3、全局变量（配置文件介绍）
            全局变量：全局所有的用户和程序都能调用，且继承，新建的用户也默认能调用
            
           
         6.4、系统变量（内置bash中变量）：shell本身已经固定好了它的名字和作用
            
        7、简单四则运算
        算术运算：默认情况下，shell就只能支持简单的整数运算
        运算内容：+ - * / %
        
        注意：用expr时运算符左右要加空格才行
        求次幂：n = 2;n = n ** 3-->n = 8
    四、条件判断与流程控制
        1、条件判断语法结构
            1.1、语法格式
                格式1：test 条件表达式
                格式2：[ 条件表达式 ]
                格式3：[[ 条件表达式 ]] 支持正则 =-
                
            1.2、条件判断相关参数
                问：你要判断什么
                答：我要判断文件类型、判断文件新旧、判断字符串是否相等、判断权限等等
                
                
                
                
                
                
        五、流程控制语句
            关键词：选择（人生漫漫长路，我该何去何从）
            5.1、if结构
            
            5.2、if...else结构
            
            练习：
                
                
            5.3、if...elif...else结构
                
                5.4、层层嵌套结构
                
            6、应用案例
                6.1、判断两台主机是否ping通
                    需求：判断当前主机是否和远程主机ping通
                    思路：    
                        1、使用哪个命令实现：ping -c次数
                        2、根据命令的执行结果状态来判断是否通：$?
                        3、根据逻辑和语法结构来编写脚本（条件判断或流程控制）
                    #! /bin/env bash
                    # 该脚本用于判断当前主机是否和远程主机互通

                    #交互式定义变量，让用户自己决定ping哪个主机
                    read  -p "请输入你要ping的主机ip:" ip
                    #使用ping程序判断主机是否互通
                    ping -c1 $ip &>/dev/nu11
                    #判断
                    if [ $?  -eq 0 ];then
                        echo "当前主机和远程主机$ip是互通的"
                    else
                        echo "不通"
                    fi
                6.2、判断一个进程是否存在
                    需求:判断web服务器中httpd进程是否存在
                    思路：
                    查看进程的相关命令：ps  pgrep top(动态查看）
                    根据命令的返回状态值来判断进程是否存在
                    根据逻辑用脚本实现
                    
                    #! /bin/env bash
                    #判断一个程序的进程httpd是否存在
                    pgrep httpd &>/dev/null
                    if [ $? -ne 0 ];then
                            echo "进程httpd不存在"
                    else 
                            echo "进程httpd存在"
                    fi
                6.3、判断一个服务是否正常
                    需求：判断门户网站是否能够正常访问
                    思路：
                    可以判断进程是否存在，用/etc/init.d/httpd status 判断状态等方法
                    最好的方法是直接去访问一下，通过访问成功和失败的返回值来判断:
                    linux环境，wget crul elinks -dump
                    #！/bin/env bash
                    #判断门户网站是否能够正常提供服务
                    #定义变量
                    web_server = www.itcast.cn
                    wget $web_server &>/dev/null
                    [ $? -eq 0 ] && echo "当前网站服务是ok"  || echo "当前网站不ok" ---相当于三元运算符
                6.4、判断用户是否存在
                    #!/bin/env bash
                    read -p "请输入一个用户名" user_name
                    id $user_name &>/dev/null
                    if [ $? -eq 0 ];then
                            echo "该用户存在"
                    else 
                            echo"该用户不存在"
                    fi
            总结：
            
            
                                

                           
    六、循环
        1、for循环语句
            1.1for循环语法结构
                列表循环
                
                例如：
                #！/bin/env bash
                #...
                for i in {1..5}
                    do
                        encho $i
                    done
                不带列表循环：
                
                类c风格
                 
应用案例1：脚本计算1-100奇数和
    思路：
        定义一个变量来保存奇数的和：sum=0
         找出1-100的奇数，保存到另一个变量里
         从1-100中找出奇数后，再相加，然后将和赋值给变量
         遍历完毕后，将sum的值打印出来
                #！/bin/env bash
                #计算1-100的奇数和
                sum=0;
                for i in {1..100..2}
                    do
                        let sum =$sum+$i   
                    done
                    encho "1-100的奇数和：$sum"
                方法二：
                #!/bin/env bash
                sum=0
                for((i=1;i<=100;i+=2))
                    do
                        let sum=$i+$sum
                    done
                    echo "1-100的奇数和为：$sum"
                
                    
切换用户命令：su
应用案例2：判断所输整数是否为质数

#! /bin/env bash
# 判断所输整数是否为质数
read -p "请输入一个正整数：" number
[ $number -eq 1 ] && echo "$number不是质数" && exit
[ $number -eq 2] && echo "$number是质数" && exit
for i in 'seq 2 $[$number-1]'  //从2开始到number-1
    do
        [ $[$number%$i] -eq 0] && echo "$number不是质数" && exit
    done
echo "$number是质数" && exit
应用案例3：批量创建用户：
    需求：批量加5个新用户，以u1到u5命名，并统一加一个新组，组名为class，统一改密码为123                    
   
#！/bin/env bash
#判断class组是否存在
grep -w ^class /etc/group &>/dev/null
test $? -ne 0 && groupadd class  //没有就创建一个
#循环创建用户
for ((i=1;i<=5;i++))
    do
        useradd -G class u$i   //创建用户并添加到class组
        echo 123|passwd --stdin u$i
    done


                     

        


