数据结构：

1、深度优先搜索和广度优先搜索
	深度优先搜索：对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。（一条分支走到头了，再进行回溯）
	广度优先搜索：BFS是从根节点开始，沿着树(图)的宽度遍历树(图)的节点。如果所有节点均被访问，则算法中止。（也就是层次遍历）
3、哈夫曼树：
	给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。
	在计算机数据处理中，哈夫曼编码使用变长编码表对源符号（如文件中的一个字母）进行编码，其中变长编码表是通过一种评估来源符号出现机率的方法得到的，出现机率高的字母使用较短的编码，反之出现机率低的则使用较长的编码，这便使编码之后的字符串的平均长度、期望值降低，从而达到无损压缩数据的目的。
4、二叉树、AVL树、红黑树、B树、B+树
	二叉树：
		二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点；
		性质：
			任意节点左子树不为空，则左子树的值均小于根节点的值
			任意节点右子树不为空，则右子树的值均大于根节点的值
			任意节点的左右子树也分别是二叉查找树
			没有键值相等的节点
		局限性：如果我们的根节点选择是最小或最大的树，那么二叉查找树就完全退化成了线性结构，和顺序查找差不多，效率低
	满二叉树：
		一颗二叉树的结点要么是叶子结点，要么它有两个子节点（如果一个二叉树的层数为k,且结点总数是(2^k)-1,则它就是满二叉树）
	完全二叉树：
		若设二叉树的深度为k，除第k层之外，其他各层（1~k-1）的节点数都达到最大个数，第k层所有的结点都连续集中在最左边，这就是完全二叉树
	AVL树：自平衡二叉树
		性质：
			是带有平衡条件的二叉查找树，一般是用平衡因子差值判断是否平衡并通过旋转来实现平衡，左右子树树高不超过1，和红黑树相比，它是严格的平衡二叉树
			所有节点的左右子树高度差不超过1
			不管我们是执行插入还是删除操作，只要不满足上面的条件，就要通过旋转来保持平衡，而旋转是非常耗时的，由此我们可以知道AVL树适合用于插入删除次数比较少，但查找多的情况
		局限性：由于维护这种高度平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树。当然，如果应用场景中对插入删除不频繁，只是对查找要求较高，那么AVL还是优于红黑树
		应用：windows NT内核中广泛存在
	红黑树：
		性质：通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍。它是一种弱平衡二叉树(由于是弱平衡，可以推出，相同的节点情况下，AVL树的高度低于红黑树)，相对于要求严格的AVL树来说，它的旋转次数变少，红黑树能够以O(log2 n)的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在三次旋转之内解决。
		性质：
			1、每个节点要么是黑色，要么是红色
			2、根节点是黑色
			3、每个叶子节点是黑色
			4、每个红色结点的两个子结点一定是黑色
			5、任意一结点到每个叶子结点的路径都包含数量相同的黑结点（黑色完美平衡）
		前面讲到红黑树能自平衡，它靠的是什么？三种操作：左旋、右旋和变色。
			左旋：以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。
			右旋：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。
			变色：结点的颜色由红变黑或由黑变红。
		插入：
			从根结点开始查找；
			若根结点为空，那么插入结点作为根结点，结束。
			若根结点不为空，那么把根结点作为当前结点；
			若当前结点为null，返回当前结点的父结点，结束。
			若当前结点key等于查找key，那么该key所在结点就是插入结点，更新结点的值，结束。
			若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤4；
			若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤4；
		查找：
			从根结点开始查找，把根结点设置为当前结点；
			若当前结点为空，返回null；
			若当前结点不为空，用当前结点的key跟查找key作比较；
			若当前结点key等于查找key，那么该key就是查找目标，返回当前结点；
			若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2；
			若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2；
		删除：
			情景1：若删除结点无子结点，直接删除
			情景2：若删除结点只有一个子结点，用子结点替换删除结点
			情景3：若删除结点有两个子结点，用后继结点（大于删除结点的最小结点）替换删除结点
			删除操作删除的结点可以看作删除替代结点，而替代结点最后总是在树末。
		应用：TreeMap TreeSet
   	B/B-树：
   		性质：
   			B树也叫平衡数，是一种多路平衡数
   			根节点至少有两个子女
   			每个中间节点都包含k-1个元素和k个孩子，其中m/2 <= k <= m
   			每一个叶子节点都包含k-1个元素，其中m/2 <= k <= m
   			所有的叶子结点都位于同一层
   			每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划
   		特点：
   			B树每一层存放了更多的节点，由AVL树的瘦高变成了矮胖。可以相对减少磁盘IO的次数。
   			B树也是一种自平衡的树，在进行插入和删除操作时也需要对结点进行旋转等操作
   			B树的查找不稳定，最好的情况就是在根节点查到了，最坏的情况就是在叶子结点查到。
   			另外，B树在遍历方面比较麻烦，由于需要进行中序遍历，所以也会进行一定数量的磁盘IO。为了解决这些问题，出现了B+树
   		应用：MongoDB的索引就是B树实现的
   	B+树：
   	   B+树每个非叶子结点存放的元素只用于索引作用，所有数据保存在叶子结点
   	   性质：
   	   		有k个子树的中间节点包含有k个元素，每个元素不保存数据，只用来索引，所有数据都保存在叶子节点
   	   		所有的叶子结点中包含了全部元素的信息，及指包含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接
   	   		所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素
   	   	特点：
   	   		因为非叶子结点中存放的元素不存放数据，所以每一层可以容纳更多元素，也就是磁盘中的每一页可以存放更多元素。这样在查找时，磁盘IO的次数也会减少
   	   		另外，B+树的查找稳定，因为所有的数据都在叶子结点。每个叶子结点也通过指针指向构成了一种链表结构，所以遍历数据也会简单很多
   	   	应用：Mysql
5、为什么说B+树比B树更适合数据库索引？
	1、B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了
	2、B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根节点到叶子节点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当
	3、由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。
6、栈和队列：
	定义：
		队列：是限定在表的一端进行插入和另一端删除的线性表
		栈：是限定只能在表的一端进行插入和删除操作的线性表
	规则：
		队列：先进先出
		栈：先进后出
	遍历数据速度：
		队列：基于地址指针进行遍历，而且可以从头部或者尾部继续遍历，但不能同时遍历，无需开辟空间，因为在遍历的过程中不影响数据结构，所以遍历速度要快
		栈：只能在顶部取数据，也就是说最先进入栈底的，需要遍历整个栈才能取出来，遍历数据时需要开辟临时空间，保持数据在遍历前的一致性
6、线性结构与非线性结构
	线性结构：线性表、栈、队列、双队列、串（一维数组）
		一个有序数据元素的集合。集合中必存在唯一的一个"第一个元素"，集合中必存在唯一的一个"最后的元素"；除最后元素外，其他数据元素均有唯一的后继；除第一个元素外，其他元素均有唯一的前继
	非线性结构：二维数组，多维数组，广义表，树（二叉树），图
		非线性结构的逻辑特征是一个结点元素可能对应多个直接前驱和多个后继
7、链表和数组插入、删除元素比较
	链表的插入、删除的时间复杂度是O(1),数组的插入、删除的时间复杂度是O(n)，因为数组是存储在连续的内存中，在插入和删除时可能需要移动数组元素
